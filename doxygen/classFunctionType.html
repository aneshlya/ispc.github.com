<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel SPMD Program Compiler: FunctionType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.12.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctionType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FunctionType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> representing a function (return type + argument types)  
 <a href="classFunctionType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FunctionType:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionType__inherit__graph.png" border="0" usemap="#FunctionType_inherit__map" alt="Inheritance graph"/></div>
<map name="FunctionType_inherit__map" id="FunctionType_inherit__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction. " alt="" coords="30,5,81,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FunctionType:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionType__coll__graph.png" border="0" usemap="#FunctionType_coll__map" alt="Collaboration graph"/></div>
<map name="FunctionType_coll__map" id="FunctionType_coll__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction. " alt="" coords="257,7,307,33"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6862a0f0276cf39fd9023959b4b45e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ab6862a0f0276cf39fd9023959b4b45e2">FunctionType</a> (const <a class="el" href="classType.html">Type</a> *<a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a>, const llvm::SmallVector&lt; const <a class="el" href="classType.html">Type</a> *, 8 &gt; &amp;argTypes, <a class="el" href="structSourcePos.html">SourcePos</a> pos)</td></tr>
<tr class="separator:ab6862a0f0276cf39fd9023959b4b45e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af063b549a3517b3c7c73faea58a36436"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#af063b549a3517b3c7c73faea58a36436">FunctionType</a> (const <a class="el" href="classType.html">Type</a> *<a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a>, const llvm::SmallVector&lt; const <a class="el" href="classType.html">Type</a> *, 8 &gt; &amp;argTypes, const llvm::SmallVector&lt; std::string, 8 &gt; &amp;argNames, const llvm::SmallVector&lt; <a class="el" href="classExpr.html">Expr</a> *, 8 &gt; &amp;argDefaults, const llvm::SmallVector&lt; <a class="el" href="structSourcePos.html">SourcePos</a>, 8 &gt; &amp;argPos, bool <a class="el" href="classFunctionType.html#a32f0aa9227794002abea1952e6c9f347">isTask</a>, bool <a class="el" href="classFunctionType.html#ad9be8ddac0b12ed937557b231319052c">isExported</a>, bool <a class="el" href="classFunctionType.html#a82597ec6f94ce5517506e306953f7eb9">isExternC</a>, bool <a class="el" href="classFunctionType.html#a4678c61188857a7671bd1539ee666f0c">isUnmasked</a>)</td></tr>
<tr class="separator:af063b549a3517b3c7c73faea58a36436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd72a5026bb2d9c9e7325a51fb3a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a52bd72a5026bb2d9c9e7325a51fb3a8d">GetVariability</a> () const</td></tr>
<tr class="separator:a52bd72a5026bb2d9c9e7325a51fb3a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a887eab839163f0e46f85e191bec774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a3a887eab839163f0e46f85e191bec774">IsBoolType</a> () const</td></tr>
<tr class="separator:a3a887eab839163f0e46f85e191bec774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41c42b12ccb6301b594591559a9a3da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ad41c42b12ccb6301b594591559a9a3da">IsFloatType</a> () const</td></tr>
<tr class="separator:ad41c42b12ccb6301b594591559a9a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e2091391eb489dc21b877679e417d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a82e2091391eb489dc21b877679e417d6">IsIntType</a> () const</td></tr>
<tr class="separator:a82e2091391eb489dc21b877679e417d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fb956fe09ef7e7135c85e4615ced1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a03fb956fe09ef7e7135c85e4615ced1d">IsUnsignedType</a> () const</td></tr>
<tr class="separator:a03fb956fe09ef7e7135c85e4615ced1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fa14aa23184b740f9b229f08478b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ab5fa14aa23184b740f9b229f08478b6b">IsConstType</a> () const</td></tr>
<tr class="separator:ab5fa14aa23184b740f9b229f08478b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f6f3db57ca651b493e43c0e3274c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a990f6f3db57ca651b493e43c0e3274c4">GetBaseType</a> () const</td></tr>
<tr class="separator:a990f6f3db57ca651b493e43c0e3274c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838ecdcc14c2a4bfed59a8322ef60a1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a838ecdcc14c2a4bfed59a8322ef60a1e">GetAsVaryingType</a> () const</td></tr>
<tr class="separator:a838ecdcc14c2a4bfed59a8322ef60a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ce9de17ec6eea155658885dd759ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#af05ce9de17ec6eea155658885dd759ba">GetAsUniformType</a> () const</td></tr>
<tr class="separator:af05ce9de17ec6eea155658885dd759ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3eaa3f4cb0b61b501a711c4fe06ba1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a8c3eaa3f4cb0b61b501a711c4fe06ba1">GetAsUnboundVariabilityType</a> () const</td></tr>
<tr class="separator:a8c3eaa3f4cb0b61b501a711c4fe06ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64e2e86945944e93eb09deadc532d22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ac64e2e86945944e93eb09deadc532d22">GetAsSOAType</a> (int width) const</td></tr>
<tr class="separator:ac64e2e86945944e93eb09deadc532d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58b8ce12713fbb1c7eb045d0abe52ae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFunctionType.html">FunctionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ac58b8ce12713fbb1c7eb045d0abe52ae">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const</td></tr>
<tr class="separator:ac58b8ce12713fbb1c7eb045d0abe52ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88097b2d325b2fae927dcc88ab16d67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#af88097b2d325b2fae927dcc88ab16d67">GetAsConstType</a> () const</td></tr>
<tr class="separator:af88097b2d325b2fae927dcc88ab16d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4b880ad5429a9e83f43bdef6c3f9ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a8a4b880ad5429a9e83f43bdef6c3f9ba">GetAsNonConstType</a> () const</td></tr>
<tr class="separator:a8a4b880ad5429a9e83f43bdef6c3f9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa7480a8d98f8265453b3b459ee2a2c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#adfa7480a8d98f8265453b3b459ee2a2c">GetString</a> () const</td></tr>
<tr class="separator:adfa7480a8d98f8265453b3b459ee2a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6fc9c1807d33b2273e300183405c53"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7a6fc9c1807d33b2273e300183405c53">Mangle</a> () const</td></tr>
<tr class="separator:a7a6fc9c1807d33b2273e300183405c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7d231a3ad8b79c4d3e1437066333cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a9e7d231a3ad8b79c4d3e1437066333cb">GetCDeclaration</a> (const std::string &amp;fname) const</td></tr>
<tr class="separator:a9e7d231a3ad8b79c4d3e1437066333cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8914d0e22c72e1a0a03013f4cafa9e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ac8914d0e22c72e1a0a03013f4cafa9e5">GetCDeclarationForDispatch</a> (const std::string &amp;fname) const</td></tr>
<tr class="separator:ac8914d0e22c72e1a0a03013f4cafa9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fdfb9cec80336002d392c9669b0ed"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#aef3fdfb9cec80336002d392c9669b0ed">LLVMType</a> (llvm::LLVMContext *ctx) const</td></tr>
<tr class="separator:aef3fdfb9cec80336002d392c9669b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7bf5e11ed1868f24cded809654d164"><td class="memItemLeft" align="right" valign="top">llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a9d7bf5e11ed1868f24cded809654d164">GetDIType</a> (llvm::DIDescriptor scope) const</td></tr>
<tr class="separator:a9d7bf5e11ed1868f24cded809654d164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba3ff1af92891ee77424b81956aef4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7bba3ff1af92891ee77424b81956aef4">GetReturnType</a> () const</td></tr>
<tr class="separator:a7bba3ff1af92891ee77424b81956aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe85ef0042554c4072072fcdb7dbd1a0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#abe85ef0042554c4072072fcdb7dbd1a0">GetReturnTypeString</a> () const</td></tr>
<tr class="separator:abe85ef0042554c4072072fcdb7dbd1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afe0d4e17748ab35a9e6e6e702e62e9"><td class="memItemLeft" align="right" valign="top">llvm::FunctionType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a1afe0d4e17748ab35a9e6e6e702e62e9">LLVMFunctionType</a> (llvm::LLVMContext *ctx, bool disableMask=false) const</td></tr>
<tr class="separator:a1afe0d4e17748ab35a9e6e6e702e62e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8b3482d1d70219401430689e9765d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a6bc8b3482d1d70219401430689e9765d">GetNumParameters</a> () const</td></tr>
<tr class="separator:a6bc8b3482d1d70219401430689e9765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd49d1c24cbe73198e35248201090389"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#afd49d1c24cbe73198e35248201090389">GetParameterType</a> (int i) const</td></tr>
<tr class="separator:afd49d1c24cbe73198e35248201090389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8f971fcefb5b16618cb0468d1b5355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExpr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7c8f971fcefb5b16618cb0468d1b5355">GetParameterDefault</a> (int i) const</td></tr>
<tr class="separator:a7c8f971fcefb5b16618cb0468d1b5355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa14e7e8ef6b46ad5ed5efa7c7cc119"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structSourcePos.html">SourcePos</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#aaaa14e7e8ef6b46ad5ed5efa7c7cc119">GetParameterSourcePos</a> (int i) const</td></tr>
<tr class="separator:aaaa14e7e8ef6b46ad5ed5efa7c7cc119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395412513cbf58f85e9b97941b810ea"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a1395412513cbf58f85e9b97941b810ea">GetParameterName</a> (int i) const</td></tr>
<tr class="separator:a1395412513cbf58f85e9b97941b810ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classType"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classType')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classType.html">Type</a></td></tr>
<tr class="memitem:a66b6da2bd1b9074f54cafd4f7cb33639 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a66b6da2bd1b9074f54cafd4f7cb33639">IsPointerType</a> () const</td></tr>
<tr class="separator:a66b6da2bd1b9074f54cafd4f7cb33639 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e279c313a458cd11804cc000c5591ad inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3e279c313a458cd11804cc000c5591ad">IsArrayType</a> () const</td></tr>
<tr class="separator:a3e279c313a458cd11804cc000c5591ad inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3196bfa8171b3e14a1b4785725b58aa inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa3196bfa8171b3e14a1b4785725b58aa">IsReferenceType</a> () const</td></tr>
<tr class="separator:aa3196bfa8171b3e14a1b4785725b58aa inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89dbc6fd641f5538ebc4351b30d7717 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa89dbc6fd641f5538ebc4351b30d7717">IsVoidType</a> () const</td></tr>
<tr class="separator:aa89dbc6fd641f5538ebc4351b30d7717 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1aee1040dc1ce32d258e221dda18f inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a0bb1aee1040dc1ce32d258e221dda18f">IsNumericType</a> () const</td></tr>
<tr class="separator:a0bb1aee1040dc1ce32d258e221dda18f inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ae2574080628114a510e26582a2e2a inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a86ae2574080628114a510e26582a2e2a">IsUniformType</a> () const</td></tr>
<tr class="separator:a86ae2574080628114a510e26582a2e2a inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d0d94b1f26a6e62d5d4cf78f1c254 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a6f3d0d94b1f26a6e62d5d4cf78f1c254">IsVaryingType</a> () const</td></tr>
<tr class="separator:a6f3d0d94b1f26a6e62d5d4cf78f1c254 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c0b710985f4bc05102e5ca7b25f3f inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a648c0b710985f4bc05102e5ca7b25f3f">IsSOAType</a> () const</td></tr>
<tr class="separator:a648c0b710985f4bc05102e5ca7b25f3f inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3edd6a2d7a3760b4e10715de5e8c7eb inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae3edd6a2d7a3760b4e10715de5e8c7eb">GetSOAWidth</a> () const</td></tr>
<tr class="separator:ae3edd6a2d7a3760b4e10715de5e8c7eb inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb77b494e53befc70e31747fdf2bd82 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb77b494e53befc70e31747fdf2bd82">HasUnboundVariability</a> () const</td></tr>
<tr class="separator:a9fb77b494e53befc70e31747fdf2bd82 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d666b04662ecb96fc6aba86888ab1 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a429d666b04662ecb96fc6aba86888ab1">GetAsUnsignedType</a> () const</td></tr>
<tr class="separator:a429d666b04662ecb96fc6aba86888ab1 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09be1885ea192d10204385e2177277 inherit pub_methods_classType"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7f09be1885ea192d10204385e2177277">GetReferenceTarget</a> () const</td></tr>
<tr class="separator:a7f09be1885ea192d10204385e2177277 inherit pub_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a32f0aa9227794002abea1952e6c9f347"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a32f0aa9227794002abea1952e6c9f347">isTask</a></td></tr>
<tr class="separator:a32f0aa9227794002abea1952e6c9f347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9be8ddac0b12ed937557b231319052c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ad9be8ddac0b12ed937557b231319052c">isExported</a></td></tr>
<tr class="separator:ad9be8ddac0b12ed937557b231319052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82597ec6f94ce5517506e306953f7eb9"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a82597ec6f94ce5517506e306953f7eb9">isExternC</a></td></tr>
<tr class="separator:a82597ec6f94ce5517506e306953f7eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4678c61188857a7671bd1539ee666f0c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a4678c61188857a7671bd1539ee666f0c">isUnmasked</a></td></tr>
<tr class="separator:a4678c61188857a7671bd1539ee666f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3d1eb3cbf748d0c0837fbd4990d8bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a4b3d1eb3cbf748d0c0837fbd4990d8bd">isSafe</a></td></tr>
<tr class="separator:a4b3d1eb3cbf748d0c0837fbd4990d8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c86736884b68abdcf8151a5c2fd669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a06c86736884b68abdcf8151a5c2fd669">costOverride</a></td></tr>
<tr class="separator:a06c86736884b68abdcf8151a5c2fd669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classType"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classType')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classType.html">Type</a></td></tr>
<tr class="memitem:ab1d91eeddf01faa36a8cccddb5bb2a06 inherit pub_attribs_classType"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab1d91eeddf01faa36a8cccddb5bb2a06">typeId</a></td></tr>
<tr class="separator:ab1d91eeddf01faa36a8cccddb5bb2a06 inherit pub_attribs_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a128c817f3a4cfdf64dbb679d7aa8e7bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a></td></tr>
<tr class="separator:a128c817f3a4cfdf64dbb679d7aa8e7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b0968e841010ff406fc853df5dd894"><td class="memItemLeft" align="right" valign="top">const llvm::SmallVector&lt; const <a class="el" href="classType.html">Type</a> *, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a03b0968e841010ff406fc853df5dd894">paramTypes</a></td></tr>
<tr class="separator:a03b0968e841010ff406fc853df5dd894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61867b25ee12933483512fb3d0f796a"><td class="memItemLeft" align="right" valign="top">const llvm::SmallVector&lt; std::string, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ad61867b25ee12933483512fb3d0f796a">paramNames</a></td></tr>
<tr class="separator:ad61867b25ee12933483512fb3d0f796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab551b31754646d5b7478b118f00a2dcb"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; <a class="el" href="classExpr.html">Expr</a> *, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ab551b31754646d5b7478b118f00a2dcb">paramDefaults</a></td></tr>
<tr class="separator:ab551b31754646d5b7478b118f00a2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383622653928b328b0155c400f06cef9"><td class="memItemLeft" align="right" valign="top">const llvm::SmallVector&lt; <a class="el" href="structSourcePos.html">SourcePos</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a383622653928b328b0155c400f06cef9">paramPositions</a></td></tr>
<tr class="separator:a383622653928b328b0155c400f06cef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classType"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classType')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classType.html">Type</a></td></tr>
<tr class="memitem:a64dc632c4a2a352b75b16c7ece65ee5f inherit pub_static_methods_classType"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a64dc632c4a2a352b75b16c7ece65ee5f">Equal</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a64dc632c4a2a352b75b16c7ece65ee5f inherit pub_static_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508f9cbb13418d10343e5fe5cd98d49 inherit pub_static_methods_classType"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a5508f9cbb13418d10343e5fe5cd98d49">EqualIgnoringConst</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a5508f9cbb13418d10343e5fe5cd98d49 inherit pub_static_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b7dc77c288701d13abaa57434da91 inherit pub_static_methods_classType"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a078b7dc77c288701d13abaa57434da91">MoreGeneralType</a> (const <a class="el" href="classType.html">Type</a> *type0, const <a class="el" href="classType.html">Type</a> *type1, <a class="el" href="structSourcePos.html">SourcePos</a> pos, const char *reason, bool forceVarying=false, int vecSize=0)</td></tr>
<tr class="separator:a078b7dc77c288701d13abaa57434da91 inherit pub_static_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae563a2978af2027bf5fc50211758f1d8 inherit pub_static_methods_classType"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae563a2978af2027bf5fc50211758f1d8">IsBasicType</a> (const <a class="el" href="classType.html">Type</a> *type)</td></tr>
<tr class="separator:ae563a2978af2027bf5fc50211758f1d8 inherit pub_static_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classType"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classType')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classType.html">Type</a></td></tr>
<tr class="memitem:ad37c99e7987655634ddb0783c9ae8fc3 inherit pro_methods_classType"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad37c99e7987655634ddb0783c9ae8fc3">Type</a> (<a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> id)</td></tr>
<tr class="separator:ad37c99e7987655634ddb0783c9ae8fc3 inherit pro_methods_classType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> representing a function (return type + argument types) </p>
<p><a class="el" href="classFunctionType.html" title="Type representing a function (return type + argument types) ">FunctionType</a> encapsulates the information related to a function's type, including the return type and the types of the arguments.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>This class has a fair number of methods inherited from <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> that don't make sense here (e.g. <a class="el" href="classType.html#a86ae2574080628114a510e26582a2e2a">IsUniformType()</a>, <a class="el" href="classFunctionType.html#a990f6f3db57ca651b493e43c0e3274c4">GetBaseType()</a>, <a class="el" href="classFunctionType.html#aef3fdfb9cec80336002d392c9669b0ed">LLVMType()</a>, etc. Would be nice to refactor the inheritance hierarchy to move most of those interface methods to a sub-class of <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a>, which in turn all of the other <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> implementations inherit from. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00858">858</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6862a0f0276cf39fd9023959b4b45e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6862a0f0276cf39fd9023959b4b45e2">&#9670;&nbsp;</a></span>FunctionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVector&lt; const <a class="el" href="classType.html">Type</a> *, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02481">2481</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, <a class="el" href="type_8h_source.html#l00935">costOverride</a>, <a class="el" href="type_8h_source.html#l00931">isSafe</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="af063b549a3517b3c7c73faea58a36436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af063b549a3517b3c7c73faea58a36436">&#9670;&nbsp;</a></span>FunctionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVector&lt; const <a class="el" href="classType.html">Type</a> *, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVector&lt; std::string, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>argNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVector&lt; <a class="el" href="classExpr.html">Expr</a> *, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>argDefaults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVector&lt; <a class="el" href="structSourcePos.html">SourcePos</a>, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>argPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExternC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isUnmasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02491">2491</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, <a class="el" href="type_8h_source.html#l00935">costOverride</a>, <a class="el" href="type_8h_source.html#l00931">isSafe</a>, <a class="el" href="type_8h_source.html#l00946">paramDefaults</a>, <a class="el" href="type_8h_source.html#l00943">paramNames</a>, <a class="el" href="type_8h_source.html#l00951">paramPositions</a>, <a class="el" href="type_8h_source.html#l00942">paramTypes</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af88097b2d325b2fae927dcc88ab16d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88097b2d325b2fae927dcc88ab16d67">&#9670;&nbsp;</a></span>GetAsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02564">2564</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="a8a4b880ad5429a9e83f43bdef6c3f9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4b880ad5429a9e83f43bdef6c3f9ba">&#9670;&nbsp;</a></span>GetAsNonConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02566">2566</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="ac64e2e86945944e93eb09deadc532d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64e2e86945944e93eb09deadc532d22">&#9670;&nbsp;</a></span>GetAsSOAType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02535">2535</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="a8c3eaa3f4cb0b61b501a711c4fe06ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3eaa3f4cb0b61b501a711c4fe06ba1">&#9670;&nbsp;</a></span>GetAsUnboundVariabilityType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implements <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02530">2530</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="af05ce9de17ec6eea155658885dd759ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05ce9de17ec6eea155658885dd759ba">&#9670;&nbsp;</a></span>GetAsUniformType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02525">2525</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="a838ecdcc14c2a4bfed59a8322ef60a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838ecdcc14c2a4bfed59a8322ef60a1e">&#9670;&nbsp;</a></span>GetAsVaryingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02520">2520</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="a990f6f3db57ca651b493e43c0e3274c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990f6f3db57ca651b493e43c0e3274c4">&#9670;&nbsp;</a></span>GetBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implements <a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02515">2515</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="a9e7d231a3ad8b79c4d3e1437066333cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7d231a3ad8b79c4d3e1437066333cb">&#9670;&nbsp;</a></span>GetCDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implements <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02598">2598</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l00923">PointerType::GetBaseType()</a>, <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type::GetCDeclaration()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="type_8h_source.html#l00943">paramNames</a>, <a class="el" href="type_8h_source.html#l00942">paramTypes</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01791">lPrintFunctionDeclarations()</a>, and <a class="el" href="module_8cpp_source.html#l02058">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="ac8914d0e22c72e1a0a03013f4cafa9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8914d0e22c72e1a0a03013f4cafa9e5">&#9670;&nbsp;</a></span>GetCDeclarationForDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::GetCDeclarationForDispatch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02626">2626</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l00923">PointerType::GetBaseType()</a>, <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01036">PointerType::GetCDeclaration()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="type_8cpp_source.html#l00997">PointerType::GetString()</a>, <a class="el" href="type_8h_source.html#l00142">Type::IsVaryingType()</a>, <a class="el" href="type_8h_source.html#l00943">paramNames</a>, <a class="el" href="type_8h_source.html#l00942">paramTypes</a>, <a class="el" href="type_8h_source.html#l00938">returnType</a>, and <a class="el" href="type_8h_source.html#l00477">PointerType::Void</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01791">lPrintFunctionDeclarations()</a>.</p>

</div>
</div>
<a id="a9d7bf5e11ed1868f24cded809654d164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7bf5e11ed1868f24cded809654d164">&#9670;&nbsp;</a></span>GetDIType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DIType FunctionType::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implements <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02670">2670</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="module_8h_source.html#l00159">Module::diBuilder</a>, <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type::GetDIType()</a>, <a class="el" href="type_8h_source.html#l00906">GetNumParameters()</a>, <a class="el" href="type_8cpp_source.html#l02802">GetParameterType()</a>, <a class="el" href="ispc_8cpp_source.html#l00102">m</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l00211">FunctionEmitContext::FunctionEmitContext()</a>.</p>

</div>
</div>
<a id="a6bc8b3482d1d70219401430689e9765d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc8b3482d1d70219401430689e9765d">&#9670;&nbsp;</a></span>GetNumParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FunctionType::GetNumParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00906">906</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l01889">emitOffloadParamStruct()</a>, <a class="el" href="func_8cpp_source.html#l00092">Function::Function()</a>, <a class="el" href="expr_8cpp_source.html#l07564">FunctionSymbolExpr::getCandidateFunctions()</a>, <a class="el" href="type_8cpp_source.html#l02670">GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l03348">FunctionCallExpr::GetValue()</a>, <a class="el" href="ctx_8cpp_source.html#l03095">lCalleeArgCount()</a>, <a class="el" href="module_8cpp_source.html#l00845">lCheckForStructParameters()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01776">lGetExportedParamTypes()</a>, <a class="el" href="module_8cpp_source.html#l02664">lGetVaryingDispatchType()</a>, <a class="el" href="expr_8cpp_source.html#l00566">PossiblyResolveFunctionOverloads()</a>, <a class="el" href="expr_8cpp_source.html#l03509">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="module_8cpp_source.html#l01923">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02058">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="a7c8f971fcefb5b16618cb0468d1b5355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8f971fcefb5b16618cb0468d1b5355">&#9670;&nbsp;</a></span>GetParameterDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExpr.html">Expr</a> * FunctionType::GetParameterDefault </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02807">2807</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, and <a class="el" href="type_8h_source.html#l00946">paramDefaults</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07564">FunctionSymbolExpr::getCandidateFunctions()</a>, <a class="el" href="expr_8cpp_source.html#l03348">FunctionCallExpr::GetValue()</a>, and <a class="el" href="expr_8cpp_source.html#l03509">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a1395412513cbf58f85e9b97941b810ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1395412513cbf58f85e9b97941b810ea">&#9670;&nbsp;</a></span>GetParameterName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; FunctionType::GetParameterName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02817">2817</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, and <a class="el" href="type_8h_source.html#l00943">paramNames</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l01889">emitOffloadParamStruct()</a>, <a class="el" href="func_8cpp_source.html#l00092">Function::Function()</a>, <a class="el" href="module_8cpp_source.html#l01923">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02058">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="aaaa14e7e8ef6b46ad5ed5efa7c7cc119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa14e7e8ef6b46ad5ed5efa7c7cc119">&#9670;&nbsp;</a></span>GetParameterSourcePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structSourcePos.html">SourcePos</a> &amp; FunctionType::GetParameterSourcePos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02812">2812</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, and <a class="el" href="type_8h_source.html#l00951">paramPositions</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>.</p>

</div>
</div>
<a id="afd49d1c24cbe73198e35248201090389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd49d1c24cbe73198e35248201090389">&#9670;&nbsp;</a></span>GetParameterType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetParameterType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02802">2802</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, and <a class="el" href="type_8h_source.html#l00942">paramTypes</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07602">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="module_8cpp_source.html#l01889">emitOffloadParamStruct()</a>, <a class="el" href="func_8cpp_source.html#l00092">Function::Function()</a>, <a class="el" href="type_8cpp_source.html#l02670">GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l03348">FunctionCallExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l00845">lCheckForStructParameters()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01776">lGetExportedParamTypes()</a>, <a class="el" href="module_8cpp_source.html#l02664">lGetVaryingDispatchType()</a>, <a class="el" href="expr_8cpp_source.html#l00566">PossiblyResolveFunctionOverloads()</a>, <a class="el" href="expr_8cpp_source.html#l03509">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="module_8cpp_source.html#l01923">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02058">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="a7bba3ff1af92891ee77424b81956aef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bba3ff1af92891ee77424b81956aef4">&#9670;&nbsp;</a></span>GetReturnType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* FunctionType::GetReturnType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00896">896</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l03112">FunctionEmitContext::CallInst()</a>, <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="expr_8cpp_source.html#l03492">FunctionCallExpr::GetLValueType()</a>, <a class="el" href="func_8cpp_source.html#l00173">Function::GetReturnType()</a>, <a class="el" href="expr_8cpp_source.html#l03479">FunctionCallExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03348">FunctionCallExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01776">lGetExportedParamTypes()</a>, <a class="el" href="expr_8cpp_source.html#l03509">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="module_8cpp_source.html#l01923">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02058">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="abe85ef0042554c4072072fcdb7dbd1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe85ef0042554c4072072fcdb7dbd1a0">&#9670;&nbsp;</a></span>GetReturnTypeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string FunctionType::GetReturnTypeString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02714">2714</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00935">costOverride</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="type_8h_source.html#l00918">isExported</a>, <a class="el" href="type_8h_source.html#l00922">isExternC</a>, <a class="el" href="type_8h_source.html#l00931">isSafe</a>, <a class="el" href="type_8h_source.html#l00914">isTask</a>, <a class="el" href="type_8h_source.html#l00927">isUnmasked</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, and <a class="el" href="type_8cpp_source.html#l02568">GetString()</a>.</p>

</div>
</div>
<a id="adfa7480a8d98f8265453b3b459ee2a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa7480a8d98f8265453b3b459ee2a2c">&#9670;&nbsp;</a></span>GetString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implements <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02568">2568</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, and <a class="el" href="type_8h_source.html#l00942">paramTypes</a>.</p>

<p class="reference">Referenced by <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="builtins_8cpp_source.html#l00165">lCreateSymbol()</a>, and <a class="el" href="expr_8cpp_source.html#l07498">lGetOverloadCandidateMessage()</a>.</p>

</div>
</div>
<a id="a52bd72a5026bb2d9c9e7325a51fb3a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bd72a5026bb2d9c9e7325a51fb3a8d">&#9670;&nbsp;</a></span>GetVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVariability.html">Variability</a> FunctionType::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implements <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02503">2503</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00059">Variability::Uniform</a>.</p>

</div>
</div>
<a id="a3a887eab839163f0e46f85e191bec774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a887eab839163f0e46f85e191bec774">&#9670;&nbsp;</a></span>IsBoolType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implements <a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02509">2509</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="ab5fa14aa23184b740f9b229f08478b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa14aa23184b740f9b229f08478b6b">&#9670;&nbsp;</a></span>IsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implements <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02513">2513</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="ad41c42b12ccb6301b594591559a9a3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41c42b12ccb6301b594591559a9a3da">&#9670;&nbsp;</a></span>IsFloatType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implements <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02505">2505</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="a82e2091391eb489dc21b877679e417d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e2091391eb489dc21b877679e417d6">&#9670;&nbsp;</a></span>IsIntType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implements <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02507">2507</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="a03fb956fe09ef7e7135c85e4615ced1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fb956fe09ef7e7135c85e4615ced1d">&#9670;&nbsp;</a></span>IsUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implements <a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02511">2511</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a id="a1afe0d4e17748ab35a9e6e6e702e62e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afe0d4e17748ab35a9e6e6e702e62e9">&#9670;&nbsp;</a></span>LLVMFunctionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::FunctionType * FunctionType::LLVMFunctionType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableMask</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the LLVM <a class="el" href="classFunctionType.html" title="Type representing a function (return type + argument types) ">FunctionType</a> that corresponds to this function type. The <code>disableMask</code> parameter indicates whether the llvm::FunctionType should have the trailing mask parameter, if present, removed from the return function signature. </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02738">2738</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, <a class="el" href="ispc_8h_source.html#l00645">Globals::ctx</a>, <a class="el" href="module_8h_source.html#l00149">Module::errorCount</a>, <a class="el" href="ispc_8cpp_source.html#l00101">g</a>, <a class="el" href="ispc_8h_source.html#l00263">Target::getISA()</a>, <a class="el" href="llvmutil_8h_source.html#l00077">LLVMTypes::Int32Type</a>, <a class="el" href="type_8h_source.html#l00914">isTask</a>, <a class="el" href="type_8h_source.html#l00927">isUnmasked</a>, <a class="el" href="type_8cpp_source.html#l00207">Type::IsVoidType()</a>, <a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">Type::LLVMType()</a>, <a class="el" href="ispc_8cpp_source.html#l00102">m</a>, <a class="el" href="llvmutil_8h_source.html#l00089">LLVMTypes::MaskType</a>, <a class="el" href="type_8h_source.html#l00942">paramTypes</a>, <a class="el" href="type_8h_source.html#l00938">returnType</a>, and <a class="el" href="ispc_8h_source.html#l00544">Globals::target</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l03112">FunctionEmitContext::CallInst()</a>, <a class="el" href="func_8cpp_source.html#l00486">Function::GenerateIR()</a>, and <a class="el" href="type_8cpp_source.html#l01083">PointerType::LLVMType()</a>.</p>

</div>
</div>
<a id="aef3fdfb9cec80336002d392c9669b0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3fdfb9cec80336002d392c9669b0ed">&#9670;&nbsp;</a></span>LLVMType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * FunctionType::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implements <a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02664">2664</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00112">FATAL</a>.</p>

</div>
</div>
<a id="a7a6fc9c1807d33b2273e300183405c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6fc9c1807d33b2273e300183405c53">&#9670;&nbsp;</a></span>Mangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implements <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02584">2584</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, <a class="el" href="module_8h_source.html#l00149">Module::errorCount</a>, <a class="el" href="type_8h_source.html#l00927">isUnmasked</a>, <a class="el" href="ispc_8cpp_source.html#l00102">m</a>, and <a class="el" href="type_8h_source.html#l00942">paramTypes</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>.</p>

</div>
</div>
<a id="ac58b8ce12713fbb1c7eb045d0abe52ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58b8ce12713fbb1c7eb045d0abe52ae">&#9670;&nbsp;</a></span>ResolveUnboundVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFunctionType.html">FunctionType</a> * FunctionType::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02540">2540</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00163">Assert</a>, <a class="el" href="type_8h_source.html#l00935">costOverride</a>, <a class="el" href="module_8h_source.html#l00149">Module::errorCount</a>, <a class="el" href="type_8cpp_source.html#l02481">FunctionType()</a>, <a class="el" href="type_8h_source.html#l00918">isExported</a>, <a class="el" href="type_8h_source.html#l00922">isExternC</a>, <a class="el" href="type_8h_source.html#l00931">isSafe</a>, <a class="el" href="type_8h_source.html#l00914">isTask</a>, <a class="el" href="type_8h_source.html#l00927">isUnmasked</a>, <a class="el" href="ispc_8cpp_source.html#l00102">m</a>, <a class="el" href="type_8h_source.html#l00946">paramDefaults</a>, <a class="el" href="type_8h_source.html#l00943">paramNames</a>, <a class="el" href="type_8h_source.html#l00951">paramPositions</a>, <a class="el" href="type_8h_source.html#l00942">paramTypes</a>, <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type::ResolveUnboundVariability()</a>, and <a class="el" href="type_8h_source.html#l00938">returnType</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06c86736884b68abdcf8151a5c2fd669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c86736884b68abdcf8151a5c2fd669">&#9670;&nbsp;</a></span>costOverride</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FunctionType::costOverride</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If non-negative, this provides a user-supplied override to the cost function estimate for the function. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00935">935</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l03635">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="type_8cpp_source.html#l02481">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="ad9be8ddac0b12ed937557b231319052c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9be8ddac0b12ed937557b231319052c">&#9670;&nbsp;</a></span>isExported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool FunctionType::isExported</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value is true if the function had a 'export' qualifier in the source program. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00918">918</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="func_8cpp_source.html#l00486">Function::GenerateIR()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01815">lIsExported()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a82597ec6f94ce5517506e306953f7eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82597ec6f94ce5517506e306953f7eb9">&#9670;&nbsp;</a></span>isExternC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool FunctionType::isExternC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value is true if the function was declared as an 'extern "C"' function in the source program. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00922">922</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="func_8cpp_source.html#l00486">Function::GenerateIR()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01821">lIsExternC()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a4b3d1eb3cbf748d0c0837fbd4990d8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3d1eb3cbf748d0c0837fbd4990d8bd">&#9670;&nbsp;</a></span>isSafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::isSafe</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this function has been declared to be safe to run with an all-off mask. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00931">931</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02481">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="ast_8cpp_source.html#l00280">lCheckAllOffSafety()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a32f0aa9227794002abea1952e6c9f347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f0aa9227794002abea1952e6c9f347">&#9670;&nbsp;</a></span>isTask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool FunctionType::isTask</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value is true if the function had a 'task' qualifier in the source program. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00914">914</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00863">Module::AddFunctionDeclaration()</a>, <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="func_8cpp_source.html#l00092">Function::Function()</a>, <a class="el" href="func_8cpp_source.html#l00486">Function::GenerateIR()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="expr_8cpp_source.html#l03348">FunctionCallExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="type_8cpp_source.html#l02738">LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>, and <a class="el" href="expr_8cpp_source.html#l03509">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a4678c61188857a7671bd1539ee666f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4678c61188857a7671bd1539ee666f0c">&#9670;&nbsp;</a></span>isUnmasked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool FunctionType::isUnmasked</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the function doesn't take an implicit mask parameter (and thus should start execution with an "all on" mask). </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00927">927</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="type_8cpp_source.html#l02738">LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02584">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="ab551b31754646d5b7478b118f00a2dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab551b31754646d5b7478b118f00a2dcb">&#9670;&nbsp;</a></span>paramDefaults</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt;<a class="el" href="classExpr.html">Expr</a> *, 8&gt; FunctionType::paramDefaults</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default values of the function's arguments. For arguments without default values provided, NULL is stored. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00946">946</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02491">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02807">GetParameterDefault()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="ad61867b25ee12933483512fb3d0f796a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61867b25ee12933483512fb3d0f796a">&#9670;&nbsp;</a></span>paramNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::SmallVector&lt;std::string, 8&gt; FunctionType::paramNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00943">943</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02491">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02598">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">GetCDeclarationForDispatch()</a>, <a class="el" href="type_8cpp_source.html#l02817">GetParameterName()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a383622653928b328b0155c400f06cef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383622653928b328b0155c400f06cef9">&#9670;&nbsp;</a></span>paramPositions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::SmallVector&lt;<a class="el" href="structSourcePos.html">SourcePos</a>, 8&gt; FunctionType::paramPositions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The names provided (if any) with the function arguments in the function's signature. These should only be used for error messages and the like and so not affect testing function types for equality, etc. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00951">951</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02491">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02812">GetParameterSourcePos()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a03b0968e841010ff406fc853df5dd894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b0968e841010ff406fc853df5dd894">&#9670;&nbsp;</a></span>paramTypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::SmallVector&lt;const <a class="el" href="classType.html">Type</a> *, 8&gt; FunctionType::paramTypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00942">942</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02491">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02598">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">GetCDeclarationForDispatch()</a>, <a class="el" href="type_8cpp_source.html#l02802">GetParameterType()</a>, <a class="el" href="type_8cpp_source.html#l02568">GetString()</a>, <a class="el" href="type_8cpp_source.html#l02738">LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02584">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a id="a128c817f3a4cfdf64dbb679d7aa8e7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128c817f3a4cfdf64dbb679d7aa8e7bf">&#9670;&nbsp;</a></span>returnType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* const FunctionType::returnType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00938">938</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02481">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02598">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">GetCDeclarationForDispatch()</a>, <a class="el" href="type_8cpp_source.html#l02670">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l02714">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l02738">LLVMFunctionType()</a>, and <a class="el" href="type_8cpp_source.html#l02540">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 15 2019 14:38:16 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
