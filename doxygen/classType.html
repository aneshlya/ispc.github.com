<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel SPMD Program Compiler: Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Type Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface class that defines the type abstraction.  
 <a href="classType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Type:</div>
<div class="dyncontent">
<div class="center"><img src="classType__inherit__graph.png" border="0" usemap="#Type_inherit__map" alt="Inheritance graph"/></div>
<map name="Type_inherit__map" id="Type_inherit__map">
<area shape="rect" id="node2" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc. " alt="" coords="134,5,233,32"/>
<area shape="rect" id="node3" href="classCollectionType.html" title="Abstract base class for types that represent collections of other types. " alt="" coords="125,56,242,83"/>
<area shape="rect" id="node8" href="classEnumType.html" title="Type implementation for enumerated types. " alt="" coords="139,107,228,133"/>
<area shape="rect" id="node9" href="classFunctionType.html" title="Type representing a function (return type + argument types) " alt="" coords="130,157,237,184"/>
<area shape="rect" id="node10" href="classPointerType.html" title="Type implementation for pointers to other types. " alt="" coords="134,208,233,235"/>
<area shape="rect" id="node11" href="classReferenceType.html" title="Type representing a reference to another (non&#45;reference) type. " alt="" coords="125,259,242,285"/>
<area shape="rect" id="node12" href="classUndefinedStructType.html" title="UndefinedStructType" alt="" coords="105,309,261,336"/>
<area shape="rect" id="node4" href="classSequentialType.html" title="Abstract base class for types that represent sequences. " alt="" coords="309,31,431,57"/>
<area shape="rect" id="node7" href="classStructType.html" title="Representation of a structure holding a number of members. " alt="" coords="325,81,415,108"/>
<area shape="rect" id="node5" href="classArrayType.html" title="One&#45;dimensional array type. " alt="" coords="482,5,569,32"/>
<area shape="rect" id="node6" href="classVectorType.html" title="A (short) vector of atomic types. " alt="" coords="479,56,572,83"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Type:</div>
<div class="dyncontent">
<div class="center"><img src="classType__coll__graph.png" border="0" usemap="#Type_coll__map" alt="Collaboration graph"/></div>
<map name="Type_coll__map" id="Type_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38ff6178597171c11f6e24566b251dea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">IsBoolType</a> () const =0</td></tr>
<tr class="separator:a38ff6178597171c11f6e24566b251dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee9fe8b11fc75a300cf37f8b5c9f034"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">IsFloatType</a> () const =0</td></tr>
<tr class="separator:aeee9fe8b11fc75a300cf37f8b5c9f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2b570093e27170d582b67211dd6836"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">IsIntType</a> () const =0</td></tr>
<tr class="separator:a3b2b570093e27170d582b67211dd6836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5648ec4eb5b432723cf0b3332f8d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">IsUnsignedType</a> () const =0</td></tr>
<tr class="separator:a9fb5648ec4eb5b432723cf0b3332f8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b6da2bd1b9074f54cafd4f7cb33639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a66b6da2bd1b9074f54cafd4f7cb33639">IsPointerType</a> () const</td></tr>
<tr class="separator:a66b6da2bd1b9074f54cafd4f7cb33639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e279c313a458cd11804cc000c5591ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3e279c313a458cd11804cc000c5591ad">IsArrayType</a> () const</td></tr>
<tr class="separator:a3e279c313a458cd11804cc000c5591ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3196bfa8171b3e14a1b4785725b58aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa3196bfa8171b3e14a1b4785725b58aa">IsReferenceType</a> () const</td></tr>
<tr class="separator:aa3196bfa8171b3e14a1b4785725b58aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89dbc6fd641f5538ebc4351b30d7717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa89dbc6fd641f5538ebc4351b30d7717">IsVoidType</a> () const</td></tr>
<tr class="separator:aa89dbc6fd641f5538ebc4351b30d7717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6d77fb89abc534e2ee1726cc13cf05"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">IsConstType</a> () const =0</td></tr>
<tr class="separator:a9a6d77fb89abc534e2ee1726cc13cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1aee1040dc1ce32d258e221dda18f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a0bb1aee1040dc1ce32d258e221dda18f">IsNumericType</a> () const</td></tr>
<tr class="separator:a0bb1aee1040dc1ce32d258e221dda18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619effc9d2d2517bd884076eb9559b65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability</a> () const =0</td></tr>
<tr class="separator:a619effc9d2d2517bd884076eb9559b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ae2574080628114a510e26582a2e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a86ae2574080628114a510e26582a2e2a">IsUniformType</a> () const</td></tr>
<tr class="separator:a86ae2574080628114a510e26582a2e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d0d94b1f26a6e62d5d4cf78f1c254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a6f3d0d94b1f26a6e62d5d4cf78f1c254">IsVaryingType</a> () const</td></tr>
<tr class="separator:a6f3d0d94b1f26a6e62d5d4cf78f1c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c0b710985f4bc05102e5ca7b25f3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a648c0b710985f4bc05102e5ca7b25f3f">IsSOAType</a> () const</td></tr>
<tr class="separator:a648c0b710985f4bc05102e5ca7b25f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3edd6a2d7a3760b4e10715de5e8c7eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae3edd6a2d7a3760b4e10715de5e8c7eb">GetSOAWidth</a> () const</td></tr>
<tr class="separator:ae3edd6a2d7a3760b4e10715de5e8c7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb77b494e53befc70e31747fdf2bd82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb77b494e53befc70e31747fdf2bd82">HasUnboundVariability</a> () const</td></tr>
<tr class="separator:a9fb77b494e53befc70e31747fdf2bd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adced497622fac125548ef5531495c738"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#adced497622fac125548ef5531495c738">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const =0</td></tr>
<tr class="separator:adced497622fac125548ef5531495c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eff8692794d3437a91404c98985d20"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">GetAsUniformType</a> () const =0</td></tr>
<tr class="separator:ab0eff8692794d3437a91404c98985d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfa3c719db7ab073c5e1f75b4041e55"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType</a> () const =0</td></tr>
<tr class="separator:aedfa3c719db7ab073c5e1f75b4041e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11499a547136ca713db16214f71ecbf2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">GetAsUnboundVariabilityType</a> () const =0</td></tr>
<tr class="separator:a11499a547136ca713db16214f71ecbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3681d5c019998d033aec355d0157c54"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">GetAsSOAType</a> (int width) const =0</td></tr>
<tr class="separator:af3681d5c019998d033aec355d0157c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d666b04662ecb96fc6aba86888ab1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a429d666b04662ecb96fc6aba86888ab1">GetAsUnsignedType</a> () const</td></tr>
<tr class="separator:a429d666b04662ecb96fc6aba86888ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af28faf17eb05982547d9b340429eb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">GetBaseType</a> () const =0</td></tr>
<tr class="separator:a51af28faf17eb05982547d9b340429eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09be1885ea192d10204385e2177277"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7f09be1885ea192d10204385e2177277">GetReferenceTarget</a> () const</td></tr>
<tr class="separator:a7f09be1885ea192d10204385e2177277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91db376e89247992a5975936c5054eaa"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">GetAsConstType</a> () const =0</td></tr>
<tr class="separator:a91db376e89247992a5975936c5054eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97d28e97d0955f6b19bb24dbfcc22bf"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType</a> () const =0</td></tr>
<tr class="separator:ad97d28e97d0955f6b19bb24dbfcc22bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1539ea0f1c563872676c3ed3cfa568"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString</a> () const =0</td></tr>
<tr class="separator:a4d1539ea0f1c563872676c3ed3cfa568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd23bd909d493d271dbe1024d212c06"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Mangle</a> () const =0</td></tr>
<tr class="separator:a7bd23bd909d493d271dbe1024d212c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e35141766bbc63333953263cd85d883"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">GetCDeclaration</a> (const std::string &amp;name) const =0</td></tr>
<tr class="separator:a7e35141766bbc63333953263cd85d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb42d850a697fc181b388688b6393e"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">LLVMType</a> (llvm::LLVMContext *ctx) const =0</td></tr>
<tr class="separator:a04eb42d850a697fc181b388688b6393e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ded269378020c769915bbbff3d73c"><td class="memItemLeft" align="right" valign="top">virtual llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">GetDIType</a> (llvm::DIDescriptor scope) const =0</td></tr>
<tr class="separator:a8b6ded269378020c769915bbbff3d73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a64dc632c4a2a352b75b16c7ece65ee5f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a64dc632c4a2a352b75b16c7ece65ee5f">Equal</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a64dc632c4a2a352b75b16c7ece65ee5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508f9cbb13418d10343e5fe5cd98d49"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a5508f9cbb13418d10343e5fe5cd98d49">EqualIgnoringConst</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a5508f9cbb13418d10343e5fe5cd98d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b7dc77c288701d13abaa57434da91"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a078b7dc77c288701d13abaa57434da91">MoreGeneralType</a> (const <a class="el" href="classType.html">Type</a> *type0, const <a class="el" href="classType.html">Type</a> *type1, <a class="el" href="structSourcePos.html">SourcePos</a> pos, const char *reason, bool forceVarying=false, int vecSize=0)</td></tr>
<tr class="separator:a078b7dc77c288701d13abaa57434da91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae563a2978af2027bf5fc50211758f1d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae563a2978af2027bf5fc50211758f1d8">IsBasicType</a> (const <a class="el" href="classType.html">Type</a> *type)</td></tr>
<tr class="separator:ae563a2978af2027bf5fc50211758f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab1d91eeddf01faa36a8cccddb5bb2a06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab1d91eeddf01faa36a8cccddb5bb2a06">typeId</a></td></tr>
<tr class="separator:ab1d91eeddf01faa36a8cccddb5bb2a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad37c99e7987655634ddb0783c9ae8fc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad37c99e7987655634ddb0783c9ae8fc3">Type</a> (<a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> id)</td></tr>
<tr class="separator:ad37c99e7987655634ddb0783c9ae8fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface class that defines the type abstraction. </p>
<p>Abstract base class that defines the interface that must be implemented for all types in the language. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00095">95</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad37c99e7987655634ddb0783c9ae8fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37c99e7987655634ddb0783c9ae8fc3">&#9670;&nbsp;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type::Type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00267">267</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64dc632c4a2a352b75b16c7ece65ee5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc632c4a2a352b75b16c7ece65ee5f">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks two types for equality. Returns true if they are exactly the same, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l03114">3114</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l04852">ConstExpr::ConstExpr()</a>, <a class="el" href="stmt_8cpp_source.html#l02047">ForeachActiveStmt::EmitCode()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07424">FunctionSymbolExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03021">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="module_8cpp_source.html#l01703">lAddTypeIfNew()</a>, <a class="el" href="builtins_8cpp_source.html#l00183">lCreateISPCSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="stmt_8cpp_source.html#l02911">lEncodeType()</a>, <a class="el" href="sym_8cpp_source.html#l00153">SymbolTable::LookupFunction()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="stmt_8cpp_source.html#l00405">DeclStmt::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02186">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l03177">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a id="a5508f9cbb13418d10343e5fe5cd98d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508f9cbb13418d10343e5fe5cd98d49">&#9670;&nbsp;</a></span>EqualIgnoringConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::EqualIgnoringConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks two types for equality. Returns true if they are exactly the same (ignoring const-ness of the type), false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l03116">3116</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l00907">PointerType::IsVoidPointer()</a>, <a class="el" href="type_8cpp_source.html#l00207">IsVoidType()</a>, <a class="el" href="expr_8cpp_source.html#l02149">lCanImproveVectorDivide()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01453">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01372">lEmitBinaryPointerArith()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l01085">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02186">BinaryExpr::Optimize()</a>, <a class="el" href="ctx_8cpp_source.html#l02892">FunctionEmitContext::storeUniformToSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04203">IndexExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02636">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a91db376e89247992a5975936c5054eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91db376e89247992a5975936c5054eaa">&#9670;&nbsp;</a></span>GetAsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#af88097b2d325b2fae927dcc88ab16d67">FunctionType</a>, <a class="el" href="classReferenceType.html#ae748985cb789cf6fd3bb72a2334ab5df">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a076802856a45f35406e6eb4dd28162a0">UndefinedStructType</a>, <a class="el" href="classStructType.html#a6a9ee5c2bc6882572d69faeaaf79856d">StructType</a>, <a class="el" href="classVectorType.html#a5befc28275a1033f3e16e7ae0885cc4d">VectorType</a>, <a class="el" href="classArrayType.html#a00826dfff913dc0b760fdde4b85ca3c0">ArrayType</a>, <a class="el" href="classPointerType.html#ab5f0afced5fcc92b3be7509c18c96684">PointerType</a>, <a class="el" href="classEnumType.html#ae4c587add6f31fa8d54a401e88b2416b">EnumType</a>, and <a class="el" href="classAtomicType.html#a80e7f458f842d9e112271bd50fd638cc">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l04852">ConstExpr::ConstExpr()</a>, <a class="el" href="type_8cpp_source.html#l01285">ArrayType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l02365">ReferenceType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l02069">StructType::GetElementType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, and <a class="el" href="stmt_8cpp_source.html#l02636">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="ad97d28e97d0955f6b19bb24dbfcc22bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97d28e97d0955f6b19bb24dbfcc22bf">&#9670;&nbsp;</a></span>GetAsNonConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a8a4b880ad5429a9e83f43bdef6c3f9ba">FunctionType</a>, <a class="el" href="classReferenceType.html#a440db1cf8d623b0aa273b17e009f3bf1">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#abf807dc01dbcfb67b40c635dbdd09045">UndefinedStructType</a>, <a class="el" href="classStructType.html#a4e39cb382ed9b53aa58aeba5e0a3e14a">StructType</a>, <a class="el" href="classVectorType.html#a4ab7adcb95037d142d9bb98a61ae1e75">VectorType</a>, <a class="el" href="classArrayType.html#aecad1e5f1c7618aa8119f30c1bbb07f3">ArrayType</a>, <a class="el" href="classPointerType.html#a30469a3d9f3a988b71fb7820ca13b5c8">PointerType</a>, <a class="el" href="classEnumType.html#a1658c4fc9f78360aabdf574e1fe27ccf">EnumType</a>, and <a class="el" href="classAtomicType.html#a9004b4b4fd6d670882dc8334864433a4">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l01293">ArrayType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l02380">ReferenceType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l02417">ReferenceType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03021">SelectExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l01703">lAddTypeIfNew()</a>, <a class="el" href="expr_8cpp_source.html#l06689">lDeconstifyType()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l02186">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l03177">SelectExpr::Optimize()</a>, and <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="af3681d5c019998d033aec355d0157c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3681d5c019998d033aec355d0157c54">&#9670;&nbsp;</a></span>GetAsSOAType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classFunctionType.html#ac64e2e86945944e93eb09deadc532d22">FunctionType</a>, <a class="el" href="classReferenceType.html#ad38bc0fb08621ff209626ba2c9b542cf">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a959c417f7c41c4f4a1d5005c28c822e8">UndefinedStructType</a>, <a class="el" href="classStructType.html#aaa6fec0d3e1e68b553adb1e4ab7c6fc9">StructType</a>, <a class="el" href="classVectorType.html#ac1e246c50bb88db15cfc3151adb47bcb">VectorType</a>, <a class="el" href="classArrayType.html#a9b0e45f80f90cf9f2df24b6ba799471c">ArrayType</a>, <a class="el" href="classPointerType.html#a46c9dd322ccfff2d22cbb6e167c3949f">PointerType</a>, <a class="el" href="classEnumType.html#a3f1b0693e7365c0781025a20343ae14b">EnumType</a>, and <a class="el" href="classAtomicType.html#a785ae13ea86a306ea5b3b619229ef941">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01261">ArrayType::GetAsSOAType()</a>.</p>

</div>
</div>
<a id="a11499a547136ca713db16214f71ecbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11499a547136ca713db16214f71ecbf2">&#9670;&nbsp;</a></span>GetAsUnboundVariabilityType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a8c3eaa3f4cb0b61b501a711c4fe06ba1">FunctionType</a>, <a class="el" href="classReferenceType.html#ac7984e426242261653720a1803d0637c">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab9580231a3c5f447796bb2ac2775f286">UndefinedStructType</a>, <a class="el" href="classStructType.html#a5205f2b1695986bd0d747c2d95c350c9">StructType</a>, <a class="el" href="classVectorType.html#a9e4d16c68274e64fd386dd930cbe919f">VectorType</a>, <a class="el" href="classArrayType.html#af9fcddd7dc94d3de121be9ca1d9b8be3">ArrayType</a>, <a class="el" href="classPointerType.html#a9b9adb47f0dc76ebc7df90b12d9b6a8f">PointerType</a>, <a class="el" href="classEnumType.html#a71b730618a30424ca95ff8c08dadde0f">EnumType</a>, and <a class="el" href="classAtomicType.html#a55f569219f44b530c53169f1d2ea2059">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01253">ArrayType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l02342">ReferenceType::GetAsUnboundVariabilityType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, and <a class="el" href="module_8cpp_source.html#l00148">lDeclareSizeAndPtrIntTypes()</a>.</p>

</div>
</div>
<a id="ab0eff8692794d3437a91404c98985d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0eff8692794d3437a91404c98985d20">&#9670;&nbsp;</a></span>GetAsUniformType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#af05ce9de17ec6eea155658885dd759ba">FunctionType</a>, <a class="el" href="classReferenceType.html#ad763b098440e967969f020098795d634">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a1ee28d0662f602252970a58ff81aaa3b">UndefinedStructType</a>, <a class="el" href="classStructType.html#a063eed8c583fa5076844407f03c4b98a">StructType</a>, <a class="el" href="classVectorType.html#a70dcf6e11c68e268caa9f2bbee00c23d">VectorType</a>, <a class="el" href="classArrayType.html#a80ad9e0f49c2aa1204482ccdf658bbb0">ArrayType</a>, <a class="el" href="classPointerType.html#aa4ea2b2c4182efda380e84b99a2baba6">PointerType</a>, <a class="el" href="classEnumType.html#a02fa13d6ba941f0a9898f86e9c5439ac">EnumType</a>, and <a class="el" href="classAtomicType.html#a04b86507e4cf005e2ca17b8d671fd454">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l03491">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l01245">ArrayType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l02332">ReferenceType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01343">ArrayType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l06897">TypeCastExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03964">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04505">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07856">NewExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="type_8cpp_source.html#l00907">PointerType::IsVoidPointer()</a>, <a class="el" href="expr_8cpp_source.html#l03820">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02309">lFinalSliceOffset()</a>, <a class="el" href="ctx_8cpp_source.html#l02338">FunctionEmitContext::loadUniformFromSOA()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="ctx_8cpp_source.html#l02892">FunctionEmitContext::storeUniformToSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04203">IndexExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02636">SwitchStmt::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a429d666b04662ecb96fc6aba86888ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429d666b04662ecb96fc6aba86888ab1">&#9670;&nbsp;</a></span>GetAsUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetAsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a signed integer type, return the unsigned version of the type. Otherwise, return the original type. </p>

<p>Reimplemented in <a class="el" href="classVectorType.html#a6c61eeeddf6f9816b054b0325537210e">VectorType</a>, <a class="el" href="classArrayType.html#a31a60237697aeb4a0f802856581f18d4">ArrayType</a>, and <a class="el" href="classAtomicType.html#a489b1123ec175892e8169d43327fc893">AtomicType</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02830">2830</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01277">ArrayType::GetAsUnsignedType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, and <a class="el" href="module_8cpp_source.html#l00148">lDeclareSizeAndPtrIntTypes()</a>.</p>

</div>
</div>
<a id="aedfa3c719db7ab073c5e1f75b4041e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfa3c719db7ab073c5e1f75b4041e55">&#9670;&nbsp;</a></span>GetAsVaryingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a838ecdcc14c2a4bfed59a8322ef60a1e">FunctionType</a>, <a class="el" href="classReferenceType.html#a27dd32d7193034e7e76cccd21cf5cc5d">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a845d950f6a061e32e48f148d43276fec">UndefinedStructType</a>, <a class="el" href="classStructType.html#a08d9210e44cdc935b67a3a5314ff7b1c">StructType</a>, <a class="el" href="classVectorType.html#afac0d24dc8aeb4481efccf78f4c9e7c5">VectorType</a>, <a class="el" href="classArrayType.html#ae3b5e21be012bc0d9b23d98003557568">ArrayType</a>, <a class="el" href="classPointerType.html#acaa03e087cbadd0910a888636f4b44b1">PointerType</a>, <a class="el" href="classEnumType.html#aa6cd1b18d07c02d8827ce6fa85fe92a1">EnumType</a>, and <a class="el" href="classAtomicType.html#ae3e12579bfad2e34c2b952e35eafa5c8">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02450">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l01237">ArrayType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l02322">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l01922">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03964">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07051">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04505">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l06342">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l03854">lVaryingStructHasUniformMember()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="ctx_8cpp_source.html#l02728">FunctionEmitContext::scatter()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02871">AssignExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l07978">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a51af28faf17eb05982547d9b340429eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51af28faf17eb05982547d9b340429eb">&#9670;&nbsp;</a></span>GetBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a990f6f3db57ca651b493e43c0e3274c4">FunctionType</a>, <a class="el" href="classReferenceType.html#ae2de13357f996978f86bebf4aa5ffdee">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#aab914dec045ab7d03dce0b889eb0bc2b">UndefinedStructType</a>, <a class="el" href="classStructType.html#af919df62ec0301cf037875ba1625fa93">StructType</a>, <a class="el" href="classVectorType.html#a90a9b9cbfec6666835319beadc173eae">VectorType</a>, <a class="el" href="classArrayType.html#abc1d21b24984837998f72b1b2b15f21e">ArrayType</a>, <a class="el" href="classPointerType.html#ae8def00d48d50dd5b950bb8d5d1bb125">PointerType</a>, <a class="el" href="classEnumType.html#aacd92eb52c0ffddf67fff69ff1cc353e">EnumType</a>, and <a class="el" href="classAtomicType.html#a2a44237711e6bbfa14d0484f7b1183a7">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03491">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l01913">FunctionEmitContext::applyVaryingGEP()</a>, <a class="el" href="expr_8cpp_source.html#l03623">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="type_8cpp_source.html#l02314">ReferenceType::GetBaseType()</a>, <a class="el" href="expr_8cpp_source.html#l04139">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04539">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07051">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03021">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l00805">lCheckExportedParameterTypes()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02309">lFinalSliceOffset()</a>, <a class="el" href="module_8cpp_source.html#l01721">lGetExportedTypes()</a>, <a class="el" href="expr_8cpp_source.html#l03319">lGetFunctionType()</a>, <a class="el" href="expr_8cpp_source.html#l00780">lLLVMConstantValue()</a>, <a class="el" href="ctx_8cpp_source.html#l02629">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l00566">PossiblyResolveFunctionOverloads()</a>, and <a class="el" href="expr_8cpp_source.html#l03497">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a7e35141766bbc63333953263cd85d883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e35141766bbc63333953263cd85d883">&#9670;&nbsp;</a></span>GetCDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a9e7d231a3ad8b79c4d3e1437066333cb">FunctionType</a>, <a class="el" href="classReferenceType.html#a6bd2666f8b883b5c13622c6cee06f95d">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab2dd62fe284fa7f2ab2a9b15423ece21">UndefinedStructType</a>, <a class="el" href="classStructType.html#af677d5f260f9beb0e5df3c6eede80744">StructType</a>, <a class="el" href="classVectorType.html#a6085a660bbb996eeeb24b3a74a615569">VectorType</a>, <a class="el" href="classArrayType.html#aefd20be03b8af662bbbd29597dff9c52">ArrayType</a>, <a class="el" href="classPointerType.html#af534fbb38a5591189c00176da08d2cfa">PointerType</a>, <a class="el" href="classEnumType.html#aff7e6d144c97b34f995ba00906c31d43">EnumType</a>, and <a class="el" href="classAtomicType.html#a42603044aa4ec1c46bf81f21d9f6ca02">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l01036">PointerType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01343">ArrayType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02417">ReferenceType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02598">FunctionType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l01666">lEmitVectorTypedefs()</a>, and <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a8b6ded269378020c769915bbbff3d73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6ded269378020c769915bbbff3d73c">&#9670;&nbsp;</a></span>GetDIType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::DIType Type::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a9d7bf5e11ed1868f24cded809654d164">FunctionType</a>, <a class="el" href="classReferenceType.html#a978bfd78fa0684ee77b313d180281689">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#adc359751cc6213c1f901e44205f1a44a">UndefinedStructType</a>, <a class="el" href="classStructType.html#a1ad28271efe223668111ce4c6c3651c8">StructType</a>, <a class="el" href="classVectorType.html#a69f992859ea8eda8cfedcd5a7a639564">VectorType</a>, <a class="el" href="classArrayType.html#ad09bddf6774cc60af0693b6e6f42c49d">ArrayType</a>, <a class="el" href="classPointerType.html#a647c767e2b5c497ec7b37f4c6fb149bd">PointerType</a>, <a class="el" href="classEnumType.html#a3b1186487e76c79fc9e1361214135919">EnumType</a>, and <a class="el" href="classAtomicType.html#aa9652418d33908640ecf0443512afed1">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l01545">FunctionEmitContext::EmitFunctionParameterDebugInfo()</a>, <a class="el" href="ctx_8cpp_source.html#l01506">FunctionEmitContext::EmitVariableDebugInfo()</a>, <a class="el" href="type_8cpp_source.html#l01141">PointerType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01391">ArrayType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01955">StructType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l02461">ReferenceType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l02670">FunctionType::GetDIType()</a>, <a class="el" href="builtins_8cpp_source.html#l00964">lDefineConstantInt()</a>, and <a class="el" href="builtins_8cpp_source.html#l01046">lDefineProgramIndex()</a>.</p>

</div>
</div>
<a id="a7f09be1885ea192d10204385e2177277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09be1885ea192d10204385e2177277">&#9670;&nbsp;</a></span>GetReferenceTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetReferenceTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a reference type, returns the type it is referring to. For all other types, just returns its own type. </p>

<p>Reimplemented in <a class="el" href="classReferenceType.html#a7c71b5f12ff7b1dc53119ab361f245a4">ReferenceType</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02825">2825</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l02179">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l04646">MemberExpr::create()</a>, <a class="el" href="ctx_8cpp_source.html#l02045">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04075">IndexExpr::GetLValue()</a>, <a class="el" href="expr_8cpp_source.html#l04139">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07344">SymbolExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04539">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l03964">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07115">RefDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07175">AddressOfExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04578">VectorMemberExpr::GetValue()</a>, <a class="el" href="ast_8cpp_source.html#l00280">lCheckAllOffSafety()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l00930">lEmitPrePostIncDec()</a>, <a class="el" href="module_8cpp_source.html#l01721">lGetExportedTypes()</a>, <a class="el" href="ctx_8cpp_source.html#l02367">FunctionEmitContext::LoadInst()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="ctx_8cpp_source.html#l02846">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l04203">IndexExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l04488">VectorMemberExpr::VectorMemberExpr()</a>.</p>

</div>
</div>
<a id="ae3edd6a2d7a3760b4e10715de5e8c7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3edd6a2d7a3760b4e10715de5e8c7eb">&#9670;&nbsp;</a></span>GetSOAWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Type::GetSOAWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the structure of arrays width for SOA types. This method returns zero for types with non-SOA variability. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00150">150</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00073">Variability::soaWidth</a>.</p>

<p class="reference">Referenced by <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="type_8cpp_source.html#l00709">EnumType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00946">PointerType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01828">StructType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01343">ArrayType::GetCDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l02045">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="decl_8cpp_source.html#l00685">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l04029">lCheckIndicesVersusBounds()</a>, <a class="el" href="expr_8cpp_source.html#l06875">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01372">lEmitBinaryPointerArith()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, and <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a4d1539ea0f1c563872676c3ed3cfa568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1539ea0f1c563872676c3ed3cfa568">&#9670;&nbsp;</a></span>GetString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implemented in <a class="el" href="classFunctionType.html#adfa7480a8d98f8265453b3b459ee2a2c">FunctionType</a>, <a class="el" href="classReferenceType.html#a82b4b3e385df40ce8471ecc30a8741e2">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5044231dcf45fef5a90342a68e39c760">UndefinedStructType</a>, <a class="el" href="classStructType.html#aa6f1489cd7032055960e50d97a0e8fbd">StructType</a>, <a class="el" href="classVectorType.html#aad47b4758dfb07c36af96a1160005e38">VectorType</a>, <a class="el" href="classArrayType.html#a6f8522e44b1d920393d206f266ffa3fe">ArrayType</a>, <a class="el" href="classPointerType.html#a18fd8f71964844a4e1284f02d3d0a0b0">PointerType</a>, <a class="el" href="classEnumType.html#a545dd6883cfdee00cf289226afa4f851">EnumType</a>, and <a class="el" href="classAtomicType.html#a294367ada4d4a7d46242ef0cc5f4fc8f">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02105">StructType::checkIfCanBeSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04646">MemberExpr::create()</a>, <a class="el" href="ctx_8cpp_source.html#l01119">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="stmt_8cpp_source.html#l02723">ReturnStmt::EmitCode()</a>, <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l02598">FunctionType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="expr_8cpp_source.html#l03674">ExprList::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07424">FunctionSymbolExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l02714">FunctionType::GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l00997">PointerType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l01305">ArrayType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l02395">ReferenceType::GetString()</a>, <a class="el" href="expr_8cpp_source.html#l03336">FunctionCallExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00262">Declarator::InitFromDeclSpecs()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l02846">lCheckForConstStructMember()</a>, <a class="el" href="expr_8cpp_source.html#l01561">lCreateBinaryOperatorCall()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02367">FunctionEmitContext::LoadInst()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l03854">lVaryingStructHasUniformMember()</a>, <a class="el" href="type_8cpp_source.html#l02839">lVectorConvert()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="decl_8cpp_source.html#l00237">DeclSpecs::Print()</a>, <a class="el" href="sym_8cpp_source.html#l00272">SymbolTable::Print()</a>, <a class="el" href="stmt_8cpp_source.html#l02172">ForeachActiveStmt::Print()</a>, <a class="el" href="stmt_8cpp_source.html#l02375">ForeachUniqueStmt::Print()</a>, <a class="el" href="expr_8cpp_source.html#l07287">SizeOfExpr::Print()</a>, <a class="el" href="expr_8cpp_source.html#l08037">NewExpr::Print()</a>, <a class="el" href="ctx_8cpp_source.html#l02846">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l01182">UnaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02871">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03497">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02404">ForeachUniqueStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04203">IndexExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l03212">DeleteStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07065">PtrDerefExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07298">SizeOfExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07978">NewExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l00549">TypeConvertExpr()</a>, and <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a619effc9d2d2517bd884076eb9559b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619effc9d2d2517bd884076eb9559b65">&#9670;&nbsp;</a></span>GetVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structVariability.html">Variability</a> Type::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a52bd72a5026bb2d9c9e7325a51fb3a8d">FunctionType</a>, <a class="el" href="classReferenceType.html#a75ed122291905627826c5657ebfd47d8">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5c8745aa5fa4169b2302e11cdf4fab9d">UndefinedStructType</a>, <a class="el" href="classStructType.html#acd0bfebc7afd26433e26b8c03f851570">StructType</a>, <a class="el" href="classVectorType.html#aecef748cf928e435c0d107aa9666b65f">VectorType</a>, <a class="el" href="classArrayType.html#ad57f9b06d2873ab74455ae13be95e60b">ArrayType</a>, <a class="el" href="classPointerType.html#ae57693ca78d176e93af004299b60bf44">PointerType</a>, <a class="el" href="classEnumType.html#ab3523bcf82e5700b3dd2b7912ea9ef05">EnumType</a>, and <a class="el" href="classAtomicType.html#a6057d942eafd33958e70d14079759e72">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8h_source.html#l00150">GetSOAWidth()</a>, <a class="el" href="type_8cpp_source.html#l01212">ArrayType::GetVariability()</a>, <a class="el" href="type_8cpp_source.html#l02264">ReferenceType::GetVariability()</a>, <a class="el" href="type_8h_source.html#l00154">HasUnboundVariability()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="type_8h_source.html#l00146">IsSOAType()</a>, <a class="el" href="type_8h_source.html#l00139">IsUniformType()</a>, <a class="el" href="type_8h_source.html#l00142">IsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, and <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>.</p>

</div>
</div>
<a id="a9fb77b494e53befc70e31747fdf2bd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb77b494e53befc70e31747fdf2bd82">&#9670;&nbsp;</a></span>HasUnboundVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::HasUnboundVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type's uniform/varying-ness is unbound. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00154">154</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00059">Variability::Unbound</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02105">StructType::checkIfCanBeSOA()</a>, <a class="el" href="type_8cpp_source.html#l00699">EnumType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l01820">StructType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l02342">ReferenceType::GetAsUnboundVariabilityType()</a>, <a class="el" href="expr_8cpp_source.html#l06680">TypeCastExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l06661">TypeCastExpr::GetType()</a>, and <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a3e279c313a458cd11804cc000c5591ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e279c313a458cd11804cc000c5591ad">&#9670;&nbsp;</a></span>IsArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a array type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00203">203</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02042">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="ae563a2978af2027bf5fc50211758f1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae563a2978af2027bf5fc50211758f1d8">&#9670;&nbsp;</a></span>IsBasicType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsBasicType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given type is an atomic, enum, or pointer type (i.e. not an aggregation of multiple instances of a type or types.) </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l03023">3023</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03491">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l01036">PointerType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l03820">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l02309">lFinalSliceOffset()</a>, <a class="el" href="expr_8cpp_source.html#l00765">lMatchingBoolType()</a>, <a class="el" href="ctx_8cpp_source.html#l02629">FunctionEmitContext::maskedStore()</a>, <a class="el" href="ctx_8cpp_source.html#l02728">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02892">FunctionEmitContext::storeUniformToSOA()</a>, and <a class="el" href="stmt_8cpp_source.html#l02404">ForeachUniqueStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a38ff6178597171c11f6e24566b251dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ff6178597171c11f6e24566b251dea">&#9670;&nbsp;</a></span>IsBoolType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a3a887eab839163f0e46f85e191bec774">FunctionType</a>, <a class="el" href="classReferenceType.html#a435acf474cd7f427869d561c00329fc3">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#aec3e05aa477649bf96aae0736fc0d035">UndefinedStructType</a>, <a class="el" href="classStructType.html#ab1246328e103c3f7a9607312c04d2373">StructType</a>, <a class="el" href="classVectorType.html#a94129dfe83055573fe59daada2e9bb56">VectorType</a>, <a class="el" href="classArrayType.html#a491e2018080a9c132bd28c41b1eeea2f">ArrayType</a>, <a class="el" href="classPointerType.html#af2af433bd10a91990de4947ccd258ed6">PointerType</a>, <a class="el" href="classEnumType.html#a7f076cc8a13f3be70ecdee4f436f605f">EnumType</a>, and <a class="el" href="classAtomicType.html#af4118c3b7edde83f45fa7ec14be63e08">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02272">ReferenceType::IsBoolType()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, and <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a9a6d77fb89abc534e2ee1726cc13cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6d77fb89abc534e2ee1726cc13cf05">&#9670;&nbsp;</a></span>IsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#ab5fa14aa23184b740f9b229f08478b6b">FunctionType</a>, <a class="el" href="classReferenceType.html#a06ca36217537aa7bd76c3581a6f019d3">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5df79c1041f69352788fc561ab0b6d0e">UndefinedStructType</a>, <a class="el" href="classStructType.html#a0e2b96684c79f2a4fcad9b1e87e37916">StructType</a>, <a class="el" href="classVectorType.html#a21bd79dacef201d2227bbddc25f3a0b6">VectorType</a>, <a class="el" href="classArrayType.html#a51fc9554e2304d9ed0ec9c3ca2da37ff">ArrayType</a>, <a class="el" href="classPointerType.html#a219727f6f17e8c9c741e9deb39c3afb7">PointerType</a>, <a class="el" href="classEnumType.html#a9fd321015dc46865b005915a67441b80">EnumType</a>, and <a class="el" href="classAtomicType.html#a8a532b43b5ff28c72b189bc6d73089aa">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l01224">ArrayType::IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l02304">ReferenceType::IsConstType()</a>, <a class="el" href="expr_8cpp_source.html#l02846">lCheckForConstStructMember()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="stmt_8cpp_source.html#l00405">DeclStmt::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l01182">UnaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02871">AssignExpr::TypeCheck()</a>, and <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="aeee9fe8b11fc75a300cf37f8b5c9f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee9fe8b11fc75a300cf37f8b5c9f034">&#9670;&nbsp;</a></span>IsFloatType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#ad41c42b12ccb6301b594591559a9a3da">FunctionType</a>, <a class="el" href="classReferenceType.html#a4398440daeeb8bad7d5eb351cc1c9886">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a62b63f3e7d31354081db38f9907d999e">UndefinedStructType</a>, <a class="el" href="classStructType.html#a1bd61a6a0ef7932e65ad24323f407215">StructType</a>, <a class="el" href="classVectorType.html#a9fa6576b15d69d22a62e268f335cc706">VectorType</a>, <a class="el" href="classArrayType.html#aa6e7926a5b6be820d997e53ab996209c">ArrayType</a>, <a class="el" href="classPointerType.html#a7cd75f6c08fc23632b07b719f7f6f2fe">PointerType</a>, <a class="el" href="classEnumType.html#ae0eecc644346d694aa5ddd321f9d0695">EnumType</a>, and <a class="el" href="classAtomicType.html#af266f218b5ed6f09eb1740da39886f9c">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02280">ReferenceType::IsFloatType()</a>, <a class="el" href="type_8h_source.html#l00133">IsNumericType()</a>, <a class="el" href="expr_8cpp_source.html#l01453">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01508">lEmitBinaryCmp()</a>, <a class="el" href="expr_8cpp_source.html#l00995">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l00930">lEmitPrePostIncDec()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02871">AssignExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a3b2b570093e27170d582b67211dd6836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2b570093e27170d582b67211dd6836">&#9670;&nbsp;</a></span>IsIntType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a82e2091391eb489dc21b877679e417d6">FunctionType</a>, <a class="el" href="classReferenceType.html#a5123bdab7765916c314067e7378e3a63">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a09e21047993b7fd308215a8a0377c2c7">UndefinedStructType</a>, <a class="el" href="classStructType.html#a9bdaccdd2ec3f52fbb474bf89ca196e5">StructType</a>, <a class="el" href="classVectorType.html#aa92a937cf9ee731f4a649bc9d2b58ce6">VectorType</a>, <a class="el" href="classArrayType.html#ab1b4e85a1d095813d5fecfc00c4387bd">ArrayType</a>, <a class="el" href="classPointerType.html#a7f053c397dc72c63c796feeb6f340956">PointerType</a>, <a class="el" href="classEnumType.html#acf40f261f54f2d7f2ffc9d84d452717d">EnumType</a>, and <a class="el" href="classAtomicType.html#acf17c4ef9795062d45e1d142d6db543e">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02288">ReferenceType::IsIntType()</a>, <a class="el" href="type_8h_source.html#l00133">IsNumericType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00995">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l00166">lIsAllIntZeros()</a>, <a class="el" href="expr_8cpp_source.html#l01182">UnaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a0bb1aee1040dc1ce32d258e221dda18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb1aee1040dc1ce32d258e221dda18f">&#9670;&nbsp;</a></span>IsNumericType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsNumericType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a float or integer type. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00133">133</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">IsFloatType()</a>, and <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">IsIntType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01182">UnaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a66b6da2bd1b9074f54cafd4f7cb33639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6da2bd1b9074f54cafd4f7cb33639">&#9670;&nbsp;</a></span>IsPointerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsPointerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is either a pointer type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00201">201</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="expr_8cpp_source.html#l03480">FunctionCallExpr::GetLValueType()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l02635">lGetVaryingDispatchType()</a>, <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02042">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="aa3196bfa8171b3e14a1b4785725b58aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3196bfa8171b3e14a1b4785725b58aa">&#9670;&nbsp;</a></span>IsReferenceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsReferenceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a array type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00205">205</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01873">emitOffloadParamStruct()</a>, <a class="el" href="expr_8cpp_source.html#l03480">FunctionCallExpr::GetLValueType()</a>, and <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a648c0b710985f4bc05102e5ca7b25f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c0b710985f4bc05102e5ca7b25f3f">&#9670;&nbsp;</a></span>IsSOAType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsSOAType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the type is laid out in "structure of arrays" layout. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00146">146</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00059">Variability::SOA</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="type_8cpp_source.html#l01576">VectorType::GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l04139">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l03964">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="type_8cpp_source.html#l01623">VectorType::getVectorMemoryCount()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l06875">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04064">lConvertPtrToSliceIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l01545">VectorType::LLVMType()</a>, and <a class="el" href="expr_8cpp_source.html#l01182">UnaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a86ae2574080628114a510e26582a2e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ae2574080628114a510e26582a2e2a">&#9670;&nbsp;</a></span>IsUniformType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is uniform </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00139">139</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00059">Variability::Uniform</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l02179">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02105">StructType::checkIfCanBeSOA()</a>, <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l04932">ConstExpr::ConstExpr()</a>, <a class="el" href="ctx_8cpp_source.html#l01119">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="decl_8cpp_source.html#l00129">DeclSpecs::DeclSpecs()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00542">IfStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00957">DoStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l01121">ForStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02723">ReturnStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02583">SwitchStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l03099">AssertStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l03159">DeleteStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00638">IfStmt::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l01093">DoStmt::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l01266">ForStmt::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l03623">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02450">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l00669">EnumType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01812">StructType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l02332">ReferenceType::GetAsUniformType()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="expr_8cpp_source.html#l03674">ExprList::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01576">VectorType::GetDIType()</a>, <a class="el" href="ctx_8cpp_source.html#l02045">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04139">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04390">StructMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04539">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="decl_8cpp_source.html#l00685">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l03964">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07051">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04505">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03021">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04578">VectorMemberExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01623">VectorType::getVectorMemoryCount()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="expr_8cpp_source.html#l03820">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="ast_8cpp_source.html#l00280">lCheckAllOffSafety()</a>, <a class="el" href="type_8cpp_source.html#l03028">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l02039">lConstFoldBinaryLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l06875">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01372">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01619">lEmitLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l00930">lEmitPrePostIncDec()</a>, <a class="el" href="module_8cpp_source.html#l01666">lEmitVectorTypedefs()</a>, <a class="el" href="stmt_8cpp_source.html#l02911">lEncodeType()</a>, <a class="el" href="ctx_8cpp_source.html#l02309">lFinalSliceOffset()</a>, <a class="el" href="expr_8cpp_source.html#l01843">lIsDifficultShiftAmount()</a>, <a class="el" href="expr_8cpp_source.html#l07470">lIsMatchWithTypeWidening()</a>, <a class="el" href="expr_8cpp_source.html#l00780">lLLVMConstantValue()</a>, <a class="el" href="type_8cpp_source.html#l01545">VectorType::LLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l00765">lMatchingBoolType()</a>, <a class="el" href="ctx_8cpp_source.html#l02367">FunctionEmitContext::LoadInst()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l05834">lTypeConvAtomic()</a>, <a class="el" href="expr_8cpp_source.html#l06342">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l03854">lVaryingStructHasUniformMember()</a>, <a class="el" href="ctx_8cpp_source.html#l02629">FunctionEmitContext::maskedStore()</a>, <a class="el" href="ctx_8cpp_source.html#l02728">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02846">FunctionEmitContext::StoreInst()</a>, <a class="el" href="stmt_8cpp_source.html#l00623">IfStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01065">DoStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01250">ForStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03497">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04203">IndexExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02636">SwitchStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l03140">AssertStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a9fb5648ec4eb5b432723cf0b3332f8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb5648ec4eb5b432723cf0b3332f8d0">&#9670;&nbsp;</a></span>IsUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a03fb956fe09ef7e7135c85e4615ced1d">FunctionType</a>, <a class="el" href="classReferenceType.html#a3dc68bc21149ca626b5368d567acf39e">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a43b8505d75d3a4e012efc82c91fe3652">UndefinedStructType</a>, <a class="el" href="classStructType.html#a592b363f12395e5ab86f66743b0d25ea">StructType</a>, <a class="el" href="classVectorType.html#a272cd03d941b5bb22dd22d7c26572722">VectorType</a>, <a class="el" href="classArrayType.html#a66ec44ebec01ec45f9e6d8cf94c6e0b8">ArrayType</a>, <a class="el" href="classPointerType.html#a700bd9930b41e22d8bf67a373575e30d">PointerType</a>, <a class="el" href="classEnumType.html#aa70c13644ae1af00f2d81a5cc7071b05">EnumType</a>, and <a class="el" href="classAtomicType.html#aaafe84a7199bf47ecc8ab4f2b550339f">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01871">BinaryExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02296">ReferenceType::IsUnsignedType()</a>, <a class="el" href="expr_8cpp_source.html#l01453">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01508">lEmitBinaryCmp()</a>, and <a class="el" href="expr_8cpp_source.html#l02686">lEmitOpAssign()</a>.</p>

</div>
</div>
<a id="a6f3d0d94b1f26a6e62d5d4cf78f1c254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3d0d94b1f26a6e62d5d4cf78f1c254">&#9670;&nbsp;</a></span>IsVaryingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is varying </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00142">142</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00059">Variability::Varying</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l03491">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="expr_8cpp_source.html#l07547">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l05657">ConstExpr::Count()</a>, <a class="el" href="decl_8cpp_source.html#l00129">DeclSpecs::DeclSpecs()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="expr_8cpp_source.html#l04268">IndexExpr::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l04805">MemberExpr::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l02667">SwitchStmt::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l07085">PtrDerefExpr::EstimateCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02450">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l00689">EnumType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01804">StructType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l02322">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l01036">PointerType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01343">ArrayType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02626">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01576">VectorType::GetDIType()</a>, <a class="el" href="ctx_8cpp_source.html#l02045">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04139">IndexExpr::GetLValueType()</a>, <a class="el" href="decl_8cpp_source.html#l00685">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l01922">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03143">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04345">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04505">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03336">FunctionCallExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03905">IndexExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l05138">ConstExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01623">VectorType::getVectorMemoryCount()</a>, <a class="el" href="expr_8cpp_source.html#l03820">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="module_8cpp_source.html#l01514">lContainsPtrToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l06875">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01453">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01508">lEmitBinaryCmp()</a>, <a class="el" href="expr_8cpp_source.html#l01372">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01619">lEmitLogicalOp()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l02635">lGetVaryingDispatchType()</a>, <a class="el" href="expr_8cpp_source.html#l01843">lIsDifficultShiftAmount()</a>, <a class="el" href="stmt_8cpp_source.html#l00896">lIsVaryingFor()</a>, <a class="el" href="type_8cpp_source.html#l01545">VectorType::LLVMType()</a>, <a class="el" href="ctx_8cpp_source.html#l02367">FunctionEmitContext::LoadInst()</a>, <a class="el" href="module_8cpp_source.html#l00765">lRecursiveCheckValidParamType()</a>, <a class="el" href="expr_8cpp_source.html#l05834">lTypeConvAtomic()</a>, <a class="el" href="expr_8cpp_source.html#l06342">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l03854">lVaryingStructHasUniformMember()</a>, <a class="el" href="ctx_8cpp_source.html#l02629">FunctionEmitContext::maskedStore()</a>, <a class="el" href="type_8cpp_source.html#l02863">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l03177">SelectExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l06775">TypeCastExpr::Optimize()</a>, <a class="el" href="ctx_8cpp_source.html#l02728">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02846">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02871">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03245">SelectExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03497">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02404">ForeachUniqueStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07298">SizeOfExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l07978">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="aa89dbc6fd641f5538ebc4351b30d7717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89dbc6fd641f5538ebc4351b30d7717">&#9670;&nbsp;</a></span>IsVoidType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsVoidType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is either a pointer or an array </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00207">207</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l03116">EqualIgnoringConst()</a>, and <a class="el" href="type_8h_source.html#l00343">AtomicType::Void</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="type_8cpp_source.html#l01192">ArrayType::ArrayType()</a>, <a class="el" href="ctx_8cpp_source.html#l01119">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="func_8cpp_source.html#l00226">Function::emitCode()</a>, <a class="el" href="ctx_8cpp_source.html#l00211">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="decl_8cpp_source.html#l00685">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l03336">FunctionCallExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00630">Declaration::GetVariableDeclarations()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="type_8cpp_source.html#l02738">FunctionType::LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l01083">PointerType::LLVMType()</a>, <a class="el" href="ctx_8cpp_source.html#l03283">FunctionEmitContext::ReturnInst()</a>, <a class="el" href="expr_8cpp_source.html#l03497">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>, <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l02042">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="a04eb42d850a697fc181b388688b6393e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eb42d850a697fc181b388688b6393e">&#9670;&nbsp;</a></span>LLVMType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* Type::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implemented in <a class="el" href="classFunctionType.html#aef3fdfb9cec80336002d392c9669b0ed">FunctionType</a>, <a class="el" href="classReferenceType.html#a4c011e2d150892da354f34b1c8f80832">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab76b7d9531557c59f4718a5541fddfbf">UndefinedStructType</a>, <a class="el" href="classStructType.html#a5ec4d8d16e49b70a94dc92da5c515137">StructType</a>, <a class="el" href="classVectorType.html#aaac5086159ec7d6558923dde03c48b53">VectorType</a>, <a class="el" href="classArrayType.html#a5a75acce8544c68388bdacb88f8f4459">ArrayType</a>, <a class="el" href="classPointerType.html#a57c6f4a639279fb4d41dbe8dae229ab1">PointerType</a>, <a class="el" href="classEnumType.html#a4ff26311dc903b2f2b9f44cc977ee871">EnumType</a>, and <a class="el" href="classAtomicType.html#a81f5374d2a68d9e29ac1983075a6d488">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l02179">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l03491">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l01913">FunctionEmitContext::applyVaryingGEP()</a>, <a class="el" href="ctx_8cpp_source.html#l03112">FunctionEmitContext::CallInst()</a>, <a class="el" href="stmt_8cpp_source.html#l00185">DeclStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02213">ForeachUniqueStmt::EmitCode()</a>, <a class="el" href="ctx_8cpp_source.html#l00211">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="ctx_8cpp_source.html#l02450">FunctionEmitContext::gather()</a>, <a class="el" href="expr_8cpp_source.html#l03674">ExprList::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l05659">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07806">NullPointerExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01955">StructType::GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l03021">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03905">IndexExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04725">MemberExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06378">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06922">ReferenceExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l07269">SizeOfExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l07856">NewExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00595">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l01372">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01619">lEmitLogicalOp()</a>, <a class="el" href="module_8cpp_source.html#l01531">lEmitStructDecl()</a>, <a class="el" href="type_8cpp_source.html#l02738">FunctionType::LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l01083">PointerType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01198">ArrayType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l02445">ReferenceType::LLVMType()</a>, <a class="el" href="ctx_8cpp_source.html#l02338">FunctionEmitContext::loadUniformFromSOA()</a>, <a class="el" href="stmt_8cpp_source.html#l02953">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l06342">lUniformValueToVarying()</a>, and <a class="el" href="type_8cpp_source.html#l01700">StructType::StructType()</a>.</p>

</div>
</div>
<a id="a7bd23bd909d493d271dbe1024d212c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd23bd909d493d271dbe1024d212c06">&#9670;&nbsp;</a></span>Mangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a7a6fc9c1807d33b2273e300183405c53">FunctionType</a>, <a class="el" href="classReferenceType.html#aadda98c0786cb5d5f07c76aca77b92f2">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a83413ab3803c932e8a15e29476b2240b">UndefinedStructType</a>, <a class="el" href="classStructType.html#a647ea56c99fb03cf8d62e7105b0da8d1">StructType</a>, <a class="el" href="classVectorType.html#a75a7e452d76081308f343698f2efe517">VectorType</a>, <a class="el" href="classArrayType.html#a5ced9573ec1451fedf707f7fe12970a0">ArrayType</a>, <a class="el" href="classPointerType.html#ad8646c014d8d04358b1e8880f7945fe8">PointerType</a>, <a class="el" href="classEnumType.html#abc453044eabe7c4fef642310697588c6">EnumType</a>, and <a class="el" href="classAtomicType.html#a9060ce0a4e6858cf6b406a13841ae023">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01017">PointerType::Mangle()</a>, <a class="el" href="type_8cpp_source.html#l01328">ArrayType::Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l02407">ReferenceType::Mangle()</a>.</p>

</div>
</div>
<a id="a078b7dc77c288701d13abaa57434da91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078b7dc77c288701d13abaa57434da91">&#9670;&nbsp;</a></span>MoreGeneralType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::MoreGeneralType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceVarying</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vecSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given two types, returns the least general <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> that is more general than both of them. (i.e. that can represent their values without any loss of data.) If there is no such <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a>, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type0</td><td>First of the two types </td></tr>
    <tr><td class="paramname">type1</td><td>Second of the two types </td></tr>
    <tr><td class="paramname">pos</td><td>Source file position where the general type is needed. </td></tr>
    <tr><td class="paramname">reason</td><td>String describing the context of why the general type is needed (e.g. "+ operator"). </td></tr>
    <tr><td class="paramname">forceVarying</td><td>If <code>true</code>, then make sure that the returned type is "varying". </td></tr>
    <tr><td class="paramname">vecSize</td><td>The vector size of the returned type. If non-zero, the returned type will be a <a class="el" href="classVectorType.html" title="A (short) vector of atomic types. ">VectorType</a> of the more general type with given length. If zero, this parameter has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The more general type, based on the provided parameters.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>the vecSize and forceVarying parts of this should probably be factored out and done separately in the cases when needed.</dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02863">2863</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="type_8h_source.html#l00330">AtomicType::basicType</a>, <a class="el" href="type_8cpp_source.html#l03114">Equal()</a>, <a class="el" href="type_8cpp_source.html#l03116">EqualIgnoringConst()</a>, <a class="el" href="util_8cpp_source.html#l00351">Error()</a>, <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType()</a>, <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01541">VectorType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01543">VectorType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l02825">GetReferenceTarget()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00899">PointerType::GetUniform()</a>, <a class="el" href="type_8h_source.html#l00142">IsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00907">PointerType::IsVoidPointer()</a>, <a class="el" href="type_8cpp_source.html#l02839">lVectorConvert()</a>, <a class="el" href="type_8h_source.html#l00338">AtomicType::UniformUInt32</a>, and <a class="el" href="type_8h_source.html#l00338">AtomicType::VaryingUInt32</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01922">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03143">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l01619">lEmitLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l02313">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l03245">SelectExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="adced497622fac125548ef5531495c738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adced497622fac125548ef5531495c738">&#9670;&nbsp;</a></span>ResolveUnboundVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classFunctionType.html#ac58b8ce12713fbb1c7eb045d0abe52ae">FunctionType</a>, <a class="el" href="classReferenceType.html#a73ebfde46e11e757f0dfba2e8c3958f4">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#afdff99026f49418a91a525b32e4bfccd">UndefinedStructType</a>, <a class="el" href="classStructType.html#a0be3702eaa8cbc4763bcf7fcbf354430">StructType</a>, <a class="el" href="classVectorType.html#aa8c03bd14a72ad6cbfc4ff3d672970e0">VectorType</a>, <a class="el" href="classArrayType.html#a5003644da005409e118e5e23dd68cd40">ArrayType</a>, <a class="el" href="classPointerType.html#a68ee39f760b455d80308768c378a097a">PointerType</a>, <a class="el" href="classEnumType.html#a94336c07b0774a2459eb96680ac6f734">EnumType</a>, and <a class="el" href="classAtomicType.html#ae31d7814a357e0cec755015d148e6a24">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02069">StructType::GetElementType()</a>, <a class="el" href="expr_8cpp_source.html#l06661">TypeCastExpr::GetType()</a>, <a class="el" href="decl_8cpp_source.html#l00630">Declaration::GetVariableDeclarations()</a>, <a class="el" href="decl_8cpp_source.html#l00335">Declarator::InitFromType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l07830">NewExpr::NewExpr()</a>, <a class="el" href="type_8cpp_source.html#l00971">PointerType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l01269">ArrayType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l02357">ReferenceType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l02540">FunctionType::ResolveUnboundVariability()</a>, <a class="el" href="expr_8cpp_source.html#l07265">SizeOfExpr::SizeOfExpr()</a>, and <a class="el" href="expr_8cpp_source.html#l06697">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1d91eeddf01faa36a8cccddb5bb2a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d91eeddf01faa36a8cccddb5bb2a06">&#9670;&nbsp;</a></span>typeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> Type::typeId</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates which <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> implementation this type is. This value can be used to determine the actual type much more efficiently than using dynamic_cast. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00264">264</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8h_source.html#l00963">CastType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 20 2019 02:49:41 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
