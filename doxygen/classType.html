<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel速 Implicit SPMD Program Compiler (Intel速 ISPC): Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel速 Implicit SPMD Program Compiler (Intel速 ISPC)
   &#160;<span id="projectnumber">1.13.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Type Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface class that defines the type abstraction.  
 <a href="classType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Type:</div>
<div class="dyncontent">
<div class="center"><img src="classType__inherit__graph.png" border="0" usemap="#Type_inherit__map" alt="Inheritance graph"/></div>
<map name="Type_inherit__map" id="Type_inherit__map">
<area shape="rect" id="node2" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc. " alt="" coords="130,5,221,32"/>
<area shape="rect" id="node3" href="classCollectionType.html" title="Abstract base class for types that represent collections of other types. " alt="" coords="122,56,229,83"/>
<area shape="rect" id="node8" href="classEnumType.html" title="Type implementation for enumerated types. " alt="" coords="134,107,217,133"/>
<area shape="rect" id="node9" href="classFunctionType.html" title="Type representing a function (return type + argument types) " alt="" coords="125,157,225,184"/>
<area shape="rect" id="node10" href="classPointerType.html" title="Type implementation for pointers to other types. " alt="" coords="130,208,221,235"/>
<area shape="rect" id="node11" href="classReferenceType.html" title="Type representing a reference to another (non&#45;reference) type. " alt="" coords="121,259,230,285"/>
<area shape="rect" id="node12" href="classUndefinedStructType.html" title="UndefinedStructType" alt="" coords="104,309,247,336"/>
<area shape="rect" id="node4" href="classSequentialType.html" title="Abstract base class for types that represent sequences. " alt="" coords="295,31,405,57"/>
<area shape="rect" id="node7" href="classStructType.html" title="Representation of a structure holding a number of members. " alt="" coords="307,81,393,108"/>
<area shape="rect" id="node5" href="classArrayType.html" title="One&#45;dimensional array type. " alt="" coords="457,5,537,32"/>
<area shape="rect" id="node6" href="classVectorType.html" title="A (short) vector of atomic types. " alt="" coords="453,56,540,83"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Type:</div>
<div class="dyncontent">
<div class="center"><img src="classType__coll__graph.png" border="0" usemap="#Type_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38ff6178597171c11f6e24566b251dea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">IsBoolType</a> () const =0</td></tr>
<tr class="separator:a38ff6178597171c11f6e24566b251dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee9fe8b11fc75a300cf37f8b5c9f034"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">IsFloatType</a> () const =0</td></tr>
<tr class="separator:aeee9fe8b11fc75a300cf37f8b5c9f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2b570093e27170d582b67211dd6836"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">IsIntType</a> () const =0</td></tr>
<tr class="separator:a3b2b570093e27170d582b67211dd6836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5648ec4eb5b432723cf0b3332f8d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">IsUnsignedType</a> () const =0</td></tr>
<tr class="separator:a9fb5648ec4eb5b432723cf0b3332f8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b6da2bd1b9074f54cafd4f7cb33639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a66b6da2bd1b9074f54cafd4f7cb33639">IsPointerType</a> () const</td></tr>
<tr class="separator:a66b6da2bd1b9074f54cafd4f7cb33639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e279c313a458cd11804cc000c5591ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3e279c313a458cd11804cc000c5591ad">IsArrayType</a> () const</td></tr>
<tr class="separator:a3e279c313a458cd11804cc000c5591ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3196bfa8171b3e14a1b4785725b58aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa3196bfa8171b3e14a1b4785725b58aa">IsReferenceType</a> () const</td></tr>
<tr class="separator:aa3196bfa8171b3e14a1b4785725b58aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89dbc6fd641f5538ebc4351b30d7717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa89dbc6fd641f5538ebc4351b30d7717">IsVoidType</a> () const</td></tr>
<tr class="separator:aa89dbc6fd641f5538ebc4351b30d7717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6d77fb89abc534e2ee1726cc13cf05"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">IsConstType</a> () const =0</td></tr>
<tr class="separator:a9a6d77fb89abc534e2ee1726cc13cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1aee1040dc1ce32d258e221dda18f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a0bb1aee1040dc1ce32d258e221dda18f">IsNumericType</a> () const</td></tr>
<tr class="separator:a0bb1aee1040dc1ce32d258e221dda18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619effc9d2d2517bd884076eb9559b65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">GetVariability</a> () const =0</td></tr>
<tr class="separator:a619effc9d2d2517bd884076eb9559b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ae2574080628114a510e26582a2e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a86ae2574080628114a510e26582a2e2a">IsUniformType</a> () const</td></tr>
<tr class="separator:a86ae2574080628114a510e26582a2e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d0d94b1f26a6e62d5d4cf78f1c254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a6f3d0d94b1f26a6e62d5d4cf78f1c254">IsVaryingType</a> () const</td></tr>
<tr class="separator:a6f3d0d94b1f26a6e62d5d4cf78f1c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c0b710985f4bc05102e5ca7b25f3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a648c0b710985f4bc05102e5ca7b25f3f">IsSOAType</a> () const</td></tr>
<tr class="separator:a648c0b710985f4bc05102e5ca7b25f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3edd6a2d7a3760b4e10715de5e8c7eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae3edd6a2d7a3760b4e10715de5e8c7eb">GetSOAWidth</a> () const</td></tr>
<tr class="separator:ae3edd6a2d7a3760b4e10715de5e8c7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb77b494e53befc70e31747fdf2bd82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb77b494e53befc70e31747fdf2bd82">HasUnboundVariability</a> () const</td></tr>
<tr class="separator:a9fb77b494e53befc70e31747fdf2bd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adced497622fac125548ef5531495c738"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#adced497622fac125548ef5531495c738">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const =0</td></tr>
<tr class="separator:adced497622fac125548ef5531495c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eff8692794d3437a91404c98985d20"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">GetAsUniformType</a> () const =0</td></tr>
<tr class="separator:ab0eff8692794d3437a91404c98985d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfa3c719db7ab073c5e1f75b4041e55"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType</a> () const =0</td></tr>
<tr class="separator:aedfa3c719db7ab073c5e1f75b4041e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11499a547136ca713db16214f71ecbf2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">GetAsUnboundVariabilityType</a> () const =0</td></tr>
<tr class="separator:a11499a547136ca713db16214f71ecbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3681d5c019998d033aec355d0157c54"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">GetAsSOAType</a> (int width) const =0</td></tr>
<tr class="separator:af3681d5c019998d033aec355d0157c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d666b04662ecb96fc6aba86888ab1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a429d666b04662ecb96fc6aba86888ab1">GetAsUnsignedType</a> () const</td></tr>
<tr class="separator:a429d666b04662ecb96fc6aba86888ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af28faf17eb05982547d9b340429eb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">GetBaseType</a> () const =0</td></tr>
<tr class="separator:a51af28faf17eb05982547d9b340429eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09be1885ea192d10204385e2177277"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7f09be1885ea192d10204385e2177277">GetReferenceTarget</a> () const</td></tr>
<tr class="separator:a7f09be1885ea192d10204385e2177277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91db376e89247992a5975936c5054eaa"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">GetAsConstType</a> () const =0</td></tr>
<tr class="separator:a91db376e89247992a5975936c5054eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97d28e97d0955f6b19bb24dbfcc22bf"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType</a> () const =0</td></tr>
<tr class="separator:ad97d28e97d0955f6b19bb24dbfcc22bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1539ea0f1c563872676c3ed3cfa568"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString</a> () const =0</td></tr>
<tr class="separator:a4d1539ea0f1c563872676c3ed3cfa568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd23bd909d493d271dbe1024d212c06"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Mangle</a> () const =0</td></tr>
<tr class="separator:a7bd23bd909d493d271dbe1024d212c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e35141766bbc63333953263cd85d883"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">GetCDeclaration</a> (const std::string &amp;name) const =0</td></tr>
<tr class="separator:a7e35141766bbc63333953263cd85d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb42d850a697fc181b388688b6393e"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">LLVMType</a> (llvm::LLVMContext *ctx) const =0</td></tr>
<tr class="separator:a04eb42d850a697fc181b388688b6393e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311bc549bbf9b4a1136a78eb276897c"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab311bc549bbf9b4a1136a78eb276897c">LLVMStorageType</a> (llvm::LLVMContext *ctx) const</td></tr>
<tr class="separator:ab311bc549bbf9b4a1136a78eb276897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0d6084272d19bd614d5cce2c738c6d"><td class="memItemLeft" align="right" valign="top">virtual llvm::DIType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a6b0d6084272d19bd614d5cce2c738c6d">GetDIType</a> (llvm::DIScope *scope) const =0</td></tr>
<tr class="separator:a6b0d6084272d19bd614d5cce2c738c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a64dc632c4a2a352b75b16c7ece65ee5f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a64dc632c4a2a352b75b16c7ece65ee5f">Equal</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a64dc632c4a2a352b75b16c7ece65ee5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508f9cbb13418d10343e5fe5cd98d49"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a5508f9cbb13418d10343e5fe5cd98d49">EqualIgnoringConst</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr class="separator:a5508f9cbb13418d10343e5fe5cd98d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b7dc77c288701d13abaa57434da91"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a078b7dc77c288701d13abaa57434da91">MoreGeneralType</a> (const <a class="el" href="classType.html">Type</a> *type0, const <a class="el" href="classType.html">Type</a> *type1, <a class="el" href="structSourcePos.html">SourcePos</a> pos, const char *reason, bool forceVarying=false, int vecSize=0)</td></tr>
<tr class="separator:a078b7dc77c288701d13abaa57434da91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae563a2978af2027bf5fc50211758f1d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ae563a2978af2027bf5fc50211758f1d8">IsBasicType</a> (const <a class="el" href="classType.html">Type</a> *type)</td></tr>
<tr class="separator:ae563a2978af2027bf5fc50211758f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab1d91eeddf01faa36a8cccddb5bb2a06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab1d91eeddf01faa36a8cccddb5bb2a06">typeId</a></td></tr>
<tr class="separator:ab1d91eeddf01faa36a8cccddb5bb2a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad37c99e7987655634ddb0783c9ae8fc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad37c99e7987655634ddb0783c9ae8fc3">Type</a> (<a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> id)</td></tr>
<tr class="separator:ad37c99e7987655634ddb0783c9ae8fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface class that defines the type abstraction. </p>
<p>Abstract base class that defines the interface that must be implemented for all types in the language. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00090">90</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad37c99e7987655634ddb0783c9ae8fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37c99e7987655634ddb0783c9ae8fc3">&#9670;&nbsp;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type::Type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00259">259</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64dc632c4a2a352b75b16c7ece65ee5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc632c4a2a352b75b16c7ece65ee5f">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks two types for equality. Returns true if they are exactly the same, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02853">2853</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00549">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00272">Module::AddGlobalVariable()</a>, <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l05017">ConstExpr::ConstExpr()</a>, <a class="el" href="stmt_8cpp_source.html#l01757">ForeachActiveStmt::EmitCode()</a>, <a class="el" href="expr_8cpp_source.html#l07694">FunctionSymbolExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03126">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="module_8cpp_source.html#l01208">lAddTypeIfNew()</a>, <a class="el" href="builtins_8cpp_source.html#l00166">lCreateISPCSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="stmt_8cpp_source.html#l02608">lEncodeType()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="sym_8cpp_source.html#l00153">SymbolTable::LookupFunction()</a>, <a class="el" href="stmt_8cpp_source.html#l02650">lProcessPrintArg()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="stmt_8cpp_source.html#l00235">DeclStmt::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02200">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l03281">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a id="a5508f9cbb13418d10343e5fe5cd98d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508f9cbb13418d10343e5fe5cd98d49">&#9670;&nbsp;</a></span>EqualIgnoringConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::EqualIgnoringConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks two types for equality. Returns true if they are exactly the same (ignoring const-ness of the type), false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02855">2855</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l00807">PointerType::IsVoidPointer()</a>, <a class="el" href="type_8cpp_source.html#l00167">IsVoidType()</a>, <a class="el" href="expr_8cpp_source.html#l02163">lCanImproveVectorDivide()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01468">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01387">lEmitBinaryPointerArith()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l01100">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02200">BinaryExpr::Optimize()</a>, <a class="el" href="ctx_8cpp_source.html#l02754">FunctionEmitContext::storeUniformToSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04361">IndexExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02333">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a91db376e89247992a5975936c5054eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91db376e89247992a5975936c5054eaa">&#9670;&nbsp;</a></span>GetAsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#af88097b2d325b2fae927dcc88ab16d67">FunctionType</a>, <a class="el" href="classReferenceType.html#ae748985cb789cf6fd3bb72a2334ab5df">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a076802856a45f35406e6eb4dd28162a0">UndefinedStructType</a>, <a class="el" href="classStructType.html#a6a9ee5c2bc6882572d69faeaaf79856d">StructType</a>, <a class="el" href="classVectorType.html#a5befc28275a1033f3e16e7ae0885cc4d">VectorType</a>, <a class="el" href="classArrayType.html#a00826dfff913dc0b760fdde4b85ca3c0">ArrayType</a>, <a class="el" href="classPointerType.html#ab5f0afced5fcc92b3be7509c18c96684">PointerType</a>, <a class="el" href="classEnumType.html#ae4c587add6f31fa8d54a401e88b2416b">EnumType</a>, and <a class="el" href="classAtomicType.html#a80e7f458f842d9e112271bd50fd638cc">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l05017">ConstExpr::ConstExpr()</a>, <a class="el" href="type_8cpp_source.html#l01167">ArrayType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l02140">ReferenceType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01859">StructType::GetElementType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, and <a class="el" href="stmt_8cpp_source.html#l02333">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="ad97d28e97d0955f6b19bb24dbfcc22bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97d28e97d0955f6b19bb24dbfcc22bf">&#9670;&nbsp;</a></span>GetAsNonConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a8a4b880ad5429a9e83f43bdef6c3f9ba">FunctionType</a>, <a class="el" href="classReferenceType.html#a440db1cf8d623b0aa273b17e009f3bf1">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#abf807dc01dbcfb67b40c635dbdd09045">UndefinedStructType</a>, <a class="el" href="classStructType.html#a4e39cb382ed9b53aa58aeba5e0a3e14a">StructType</a>, <a class="el" href="classVectorType.html#a4ab7adcb95037d142d9bb98a61ae1e75">VectorType</a>, <a class="el" href="classArrayType.html#aecad1e5f1c7618aa8119f30c1bbb07f3">ArrayType</a>, <a class="el" href="classPointerType.html#a30469a3d9f3a988b71fb7820ca13b5c8">PointerType</a>, <a class="el" href="classEnumType.html#a1658c4fc9f78360aabdf574e1fe27ccf">EnumType</a>, and <a class="el" href="classAtomicType.html#a9004b4b4fd6d670882dc8334864433a4">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l01175">ArrayType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l02155">ReferenceType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l02192">ReferenceType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l03126">SelectExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l01208">lAddTypeIfNew()</a>, <a class="el" href="expr_8cpp_source.html#l06887">lDeconstifyType()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02650">lProcessPrintArg()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l02200">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l03281">SelectExpr::Optimize()</a>, and <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="af3681d5c019998d033aec355d0157c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3681d5c019998d033aec355d0157c54">&#9670;&nbsp;</a></span>GetAsSOAType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classFunctionType.html#ac64e2e86945944e93eb09deadc532d22">FunctionType</a>, <a class="el" href="classReferenceType.html#ad38bc0fb08621ff209626ba2c9b542cf">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a959c417f7c41c4f4a1d5005c28c822e8">UndefinedStructType</a>, <a class="el" href="classStructType.html#aaa6fec0d3e1e68b553adb1e4ab7c6fc9">StructType</a>, <a class="el" href="classVectorType.html#ac1e246c50bb88db15cfc3151adb47bcb">VectorType</a>, <a class="el" href="classArrayType.html#a9b0e45f80f90cf9f2df24b6ba799471c">ArrayType</a>, <a class="el" href="classPointerType.html#a46c9dd322ccfff2d22cbb6e167c3949f">PointerType</a>, <a class="el" href="classEnumType.html#a3f1b0693e7365c0781025a20343ae14b">EnumType</a>, and <a class="el" href="classAtomicType.html#a785ae13ea86a306ea5b3b619229ef941">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01143">ArrayType::GetAsSOAType()</a>.</p>

</div>
</div>
<a id="a11499a547136ca713db16214f71ecbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11499a547136ca713db16214f71ecbf2">&#9670;&nbsp;</a></span>GetAsUnboundVariabilityType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a8c3eaa3f4cb0b61b501a711c4fe06ba1">FunctionType</a>, <a class="el" href="classReferenceType.html#ac7984e426242261653720a1803d0637c">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab9580231a3c5f447796bb2ac2775f286">UndefinedStructType</a>, <a class="el" href="classStructType.html#a5205f2b1695986bd0d747c2d95c350c9">StructType</a>, <a class="el" href="classVectorType.html#a9e4d16c68274e64fd386dd930cbe919f">VectorType</a>, <a class="el" href="classArrayType.html#af9fcddd7dc94d3de121be9ca1d9b8be3">ArrayType</a>, <a class="el" href="classPointerType.html#a9b9adb47f0dc76ebc7df90b12d9b6a8f">PointerType</a>, <a class="el" href="classEnumType.html#a71b730618a30424ca95ff8c08dadde0f">EnumType</a>, and <a class="el" href="classAtomicType.html#a55f569219f44b530c53169f1d2ea2059">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01135">ArrayType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l02117">ReferenceType::GetAsUnboundVariabilityType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, and <a class="el" href="module_8cpp_source.html#l00106">lDeclareSizeAndPtrIntTypes()</a>.</p>

</div>
</div>
<a id="ab0eff8692794d3437a91404c98985d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0eff8692794d3437a91404c98985d20">&#9670;&nbsp;</a></span>GetAsUniformType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#af05ce9de17ec6eea155658885dd759ba">FunctionType</a>, <a class="el" href="classReferenceType.html#ad763b098440e967969f020098795d634">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a1ee28d0662f602252970a58ff81aaa3b">UndefinedStructType</a>, <a class="el" href="classStructType.html#a063eed8c583fa5076844407f03c4b98a">StructType</a>, <a class="el" href="classVectorType.html#a70dcf6e11c68e268caa9f2bbee00c23d">VectorType</a>, <a class="el" href="classArrayType.html#a80ad9e0f49c2aa1204482ccdf658bbb0">ArrayType</a>, <a class="el" href="classPointerType.html#aa4ea2b2c4182efda380e84b99a2baba6">PointerType</a>, <a class="el" href="classEnumType.html#a02fa13d6ba941f0a9898f86e9c5439ac">EnumType</a>, and <a class="el" href="classAtomicType.html#a04b86507e4cf005e2ca17b8d671fd454">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03253">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l01127">ArrayType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l02107">ReferenceType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01226">ArrayType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07095">TypeCastExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04121">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04663">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l08125">NewExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="type_8cpp_source.html#l00807">PointerType::IsVoidPointer()</a>, <a class="el" href="expr_8cpp_source.html#l03977">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02114">lFinalSliceOffset()</a>, <a class="el" href="expr_8cpp_source.html#l03781">lGetExprListConstant()</a>, <a class="el" href="ctx_8cpp_source.html#l02143">FunctionEmitContext::loadUniformFromSOA()</a>, <a class="el" href="stmt_8cpp_source.html#l02650">lProcessPrintArg()</a>, <a class="el" href="ctx_8cpp_source.html#l02754">FunctionEmitContext::storeUniformToSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04361">IndexExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02333">SwitchStmt::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a429d666b04662ecb96fc6aba86888ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429d666b04662ecb96fc6aba86888ab1">&#9670;&nbsp;</a></span>GetAsUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetAsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a signed integer type, return the unsigned version of the type. Otherwise, return the original type. </p>

<p>Reimplemented in <a class="el" href="classVectorType.html#a6c61eeeddf6f9816b054b0325537210e">VectorType</a>, <a class="el" href="classArrayType.html#a31a60237697aeb4a0f802856581f18d4">ArrayType</a>, and <a class="el" href="classAtomicType.html#a489b1123ec175892e8169d43327fc893">AtomicType</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02569">2569</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01159">ArrayType::GetAsUnsignedType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, and <a class="el" href="module_8cpp_source.html#l00106">lDeclareSizeAndPtrIntTypes()</a>.</p>

</div>
</div>
<a id="aedfa3c719db7ab073c5e1f75b4041e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfa3c719db7ab073c5e1f75b4041e55">&#9670;&nbsp;</a></span>GetAsVaryingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a838ecdcc14c2a4bfed59a8322ef60a1e">FunctionType</a>, <a class="el" href="classReferenceType.html#a27dd32d7193034e7e76cccd21cf5cc5d">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a845d950f6a061e32e48f148d43276fec">UndefinedStructType</a>, <a class="el" href="classStructType.html#a08d9210e44cdc935b67a3a5314ff7b1c">StructType</a>, <a class="el" href="classVectorType.html#afac0d24dc8aeb4481efccf78f4c9e7c5">VectorType</a>, <a class="el" href="classArrayType.html#ae3b5e21be012bc0d9b23d98003557568">ArrayType</a>, <a class="el" href="classPointerType.html#acaa03e087cbadd0910a888636f4b44b1">PointerType</a>, <a class="el" href="classEnumType.html#aa6cd1b18d07c02d8827ce6fa85fe92a1">EnumType</a>, and <a class="el" href="classAtomicType.html#ae3e12579bfad2e34c2b952e35eafa5c8">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02268">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l01119">ArrayType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l02097">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l01936">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04121">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07272">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04663">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l06518">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l04011">lVaryingStructHasUniformMember()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="ctx_8cpp_source.html#l02569">FunctionEmitContext::scatter()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02976">AssignExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l08247">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a51af28faf17eb05982547d9b340429eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51af28faf17eb05982547d9b340429eb">&#9670;&nbsp;</a></span>GetBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a990f6f3db57ca651b493e43c0e3274c4">FunctionType</a>, <a class="el" href="classReferenceType.html#ae2de13357f996978f86bebf4aa5ffdee">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#aab914dec045ab7d03dce0b889eb0bc2b">UndefinedStructType</a>, <a class="el" href="classStructType.html#af919df62ec0301cf037875ba1625fa93">StructType</a>, <a class="el" href="classVectorType.html#a90a9b9cbfec6666835319beadc173eae">VectorType</a>, <a class="el" href="classArrayType.html#abc1d21b24984837998f72b1b2b15f21e">ArrayType</a>, <a class="el" href="classPointerType.html#ae8def00d48d50dd5b950bb8d5d1bb125">PointerType</a>, <a class="el" href="classEnumType.html#aacd92eb52c0ffddf67fff69ff1cc353e">EnumType</a>, and <a class="el" href="classAtomicType.html#a2a44237711e6bbfa14d0484f7b1183a7">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03253">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l02442">FunctionEmitContext::AllocaInst()</a>, <a class="el" href="ctx_8cpp_source.html#l01693">FunctionEmitContext::applyVaryingGEP()</a>, <a class="el" href="expr_8cpp_source.html#l03730">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="type_8cpp_source.html#l02089">ReferenceType::GetBaseType()</a>, <a class="el" href="expr_8cpp_source.html#l04297">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04697">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07272">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03126">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l00505">lCheckExportedParameterTypes()</a>, <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02114">lFinalSliceOffset()</a>, <a class="el" href="module_8cpp_source.html#l01226">lGetExportedTypes()</a>, <a class="el" href="expr_8cpp_source.html#l03429">lGetFunctionType()</a>, <a class="el" href="expr_8cpp_source.html#l00794">lLLVMConstantValue()</a>, <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::LoadInst()</a>, <a class="el" href="ctx_8cpp_source.html#l02464">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l00565">PossiblyResolveFunctionOverloads()</a>, and <a class="el" href="expr_8cpp_source.html#l03604">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a7e35141766bbc63333953263cd85d883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e35141766bbc63333953263cd85d883">&#9670;&nbsp;</a></span>GetCDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a9e7d231a3ad8b79c4d3e1437066333cb">FunctionType</a>, <a class="el" href="classReferenceType.html#a6bd2666f8b883b5c13622c6cee06f95d">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab2dd62fe284fa7f2ab2a9b15423ece21">UndefinedStructType</a>, <a class="el" href="classStructType.html#af677d5f260f9beb0e5df3c6eede80744">StructType</a>, <a class="el" href="classVectorType.html#a6085a660bbb996eeeb24b3a74a615569">VectorType</a>, <a class="el" href="classArrayType.html#aefd20be03b8af662bbbd29597dff9c52">ArrayType</a>, <a class="el" href="classPointerType.html#af534fbb38a5591189c00176da08d2cfa">PointerType</a>, <a class="el" href="classEnumType.html#aff7e6d144c97b34f995ba00906c31d43">EnumType</a>, and <a class="el" href="classAtomicType.html#a42603044aa4ec1c46bf81f21d9f6ca02">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l00936">PointerType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01226">ArrayType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02192">ReferenceType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02364">FunctionType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02392">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l01171">lEmitVectorTypedefs()</a>, and <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a6b0d6084272d19bd614d5cce2c738c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0d6084272d19bd614d5cce2c738c6d">&#9670;&nbsp;</a></span>GetDIType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::DIType* Type::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIScope *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a931130a232b6c9f14a1d3be28a60ad32">FunctionType</a>, <a class="el" href="classReferenceType.html#a922870b5da890a2eeeda2f415b815e21">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#afb8e58c893493804fc703bdba98b6652">UndefinedStructType</a>, <a class="el" href="classStructType.html#ae432af54749a3e0d3a4384447ebd6734">StructType</a>, <a class="el" href="classVectorType.html#af8723608080ba0eeb919efc599bc22a9">VectorType</a>, <a class="el" href="classArrayType.html#a8fc5e674d9d3b6161b7b955d2e2deac0">ArrayType</a>, <a class="el" href="classPointerType.html#addecd46bd86877c36776eda87723cabd">PointerType</a>, <a class="el" href="classEnumType.html#a2342b929607f3d3625c68bcb23cbce1b">EnumType</a>, and <a class="el" href="classAtomicType.html#a3406c4487f7c6eae7c69a3ff8eb48a77">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00272">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l01348">FunctionEmitContext::EmitFunctionParameterDebugInfo()</a>, <a class="el" href="ctx_8cpp_source.html#l01333">FunctionEmitContext::EmitVariableDebugInfo()</a>, <a class="el" href="type_8cpp_source.html#l01040">PointerType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01274">ArrayType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01820">StructType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l02235">ReferenceType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l02435">FunctionType::GetDIType()</a>, <a class="el" href="builtins_8cpp_source.html#l00822">lDefineConstantInt()</a>, and <a class="el" href="builtins_8cpp_source.html#l00869">lDefineProgramIndex()</a>.</p>

</div>
</div>
<a id="a7f09be1885ea192d10204385e2177277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09be1885ea192d10204385e2177277">&#9670;&nbsp;</a></span>GetReferenceTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetReferenceTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a reference type, returns the type it is referring to. For all other types, just returns its own type. </p>

<p>Reimplemented in <a class="el" href="classReferenceType.html#a7c71b5f12ff7b1dc53119ab361f245a4">ReferenceType</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02564">2564</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l01951">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l04811">MemberExpr::create()</a>, <a class="el" href="ctx_8cpp_source.html#l01825">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04233">IndexExpr::GetLValue()</a>, <a class="el" href="expr_8cpp_source.html#l04297">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07614">SymbolExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04697">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04121">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07336">RefDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07396">AddressOfExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04736">VectorMemberExpr::GetValue()</a>, <a class="el" href="ast_8cpp_source.html#l00280">lCheckAllOffSafety()</a>, <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l00944">lEmitPrePostIncDec()</a>, <a class="el" href="module_8cpp_source.html#l01226">lGetExportedTypes()</a>, <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::LoadInst()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="ctx_8cpp_source.html#l02708">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l03349">SelectExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04361">IndexExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l04646">VectorMemberExpr::VectorMemberExpr()</a>.</p>

</div>
</div>
<a id="ae3edd6a2d7a3760b4e10715de5e8c7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3edd6a2d7a3760b4e10715de5e8c7eb">&#9670;&nbsp;</a></span>GetSOAWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Type::GetSOAWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the structure of arrays width for SOA types. This method returns zero for types with non-SOA variability. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00145">145</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l00643">EnumType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00846">PointerType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01696">StructType::GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01226">ArrayType::GetCDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l01825">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="decl_8cpp_source.html#l00669">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l04186">lCheckIndicesVersusBounds()</a>, <a class="el" href="expr_8cpp_source.html#l07073">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01387">lEmitBinaryPointerArith()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, and <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a4d1539ea0f1c563872676c3ed3cfa568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1539ea0f1c563872676c3ed3cfa568">&#9670;&nbsp;</a></span>GetString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implemented in <a class="el" href="classFunctionType.html#adfa7480a8d98f8265453b3b459ee2a2c">FunctionType</a>, <a class="el" href="classReferenceType.html#a82b4b3e385df40ce8471ecc30a8741e2">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5044231dcf45fef5a90342a68e39c760">UndefinedStructType</a>, <a class="el" href="classStructType.html#aa6f1489cd7032055960e50d97a0e8fbd">StructType</a>, <a class="el" href="classVectorType.html#aad47b4758dfb07c36af96a1160005e38">VectorType</a>, <a class="el" href="classArrayType.html#a6f8522e44b1d920393d206f266ffa3fe">ArrayType</a>, <a class="el" href="classPointerType.html#a18fd8f71964844a4e1284f02d3d0a0b0">PointerType</a>, <a class="el" href="classEnumType.html#a545dd6883cfdee00cf289226afa4f851">EnumType</a>, and <a class="el" href="classAtomicType.html#a294367ada4d4a7d46242ef0cc5f4fc8f">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01895">StructType::checkIfCanBeSOA()</a>, <a class="el" href="expr_8cpp_source.html#l04811">MemberExpr::create()</a>, <a class="el" href="ctx_8cpp_source.html#l01055">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="stmt_8cpp_source.html#l02420">ReturnStmt::EmitCode()</a>, <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l02364">FunctionType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02392">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="expr_8cpp_source.html#l07694">FunctionSymbolExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l02452">FunctionType::GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l00897">PointerType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l01187">ArrayType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l02170">ReferenceType::GetString()</a>, <a class="el" href="expr_8cpp_source.html#l03446">FunctionCallExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00253">Declarator::InitFromDeclSpecs()</a>, <a class="el" href="decl_8cpp_source.html#l00326">Declarator::InitFromType()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l02951">lCheckForConstStructMember()</a>, <a class="el" href="expr_8cpp_source.html#l01576">lCreateBinaryOperatorCall()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03781">lGetExprListConstant()</a>, <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::LoadInst()</a>, <a class="el" href="stmt_8cpp_source.html#l02650">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l04011">lVaryingStructHasUniformMember()</a>, <a class="el" href="type_8cpp_source.html#l02578">lVectorConvert()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="decl_8cpp_source.html#l00228">DeclSpecs::Print()</a>, <a class="el" href="sym_8cpp_source.html#l00272">SymbolTable::Print()</a>, <a class="el" href="stmt_8cpp_source.html#l01877">ForeachActiveStmt::Print()</a>, <a class="el" href="stmt_8cpp_source.html#l02072">ForeachUniqueStmt::Print()</a>, <a class="el" href="expr_8cpp_source.html#l07544">SizeOfExpr::Print()</a>, <a class="el" href="expr_8cpp_source.html#l08300">NewExpr::Print()</a>, <a class="el" href="ctx_8cpp_source.html#l02708">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l01197">UnaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02976">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03604">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02101">ForeachUniqueStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04361">IndexExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02903">DeleteStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07286">PtrDerefExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l07555">SizeOfExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l08247">NewExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l00548">TypeConvertExpr()</a>, and <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a619effc9d2d2517bd884076eb9559b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619effc9d2d2517bd884076eb9559b65">&#9670;&nbsp;</a></span>GetVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structVariability.html">Variability</a> Type::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a52bd72a5026bb2d9c9e7325a51fb3a8d">FunctionType</a>, <a class="el" href="classReferenceType.html#a75ed122291905627826c5657ebfd47d8">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5c8745aa5fa4169b2302e11cdf4fab9d">UndefinedStructType</a>, <a class="el" href="classStructType.html#acd0bfebc7afd26433e26b8c03f851570">StructType</a>, <a class="el" href="classVectorType.html#aecef748cf928e435c0d107aa9666b65f">VectorType</a>, <a class="el" href="classArrayType.html#ad57f9b06d2873ab74455ae13be95e60b">ArrayType</a>, <a class="el" href="classPointerType.html#ae57693ca78d176e93af004299b60bf44">PointerType</a>, <a class="el" href="classEnumType.html#ab3523bcf82e5700b3dd2b7912ea9ef05">EnumType</a>, and <a class="el" href="classAtomicType.html#a6057d942eafd33958e70d14079759e72">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01094">ArrayType::GetVariability()</a>, <a class="el" href="type_8cpp_source.html#l02039">ReferenceType::GetVariability()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>, and <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>.</p>

</div>
</div>
<a id="a9fb77b494e53befc70e31747fdf2bd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb77b494e53befc70e31747fdf2bd82">&#9670;&nbsp;</a></span>HasUnboundVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::HasUnboundVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type's uniform/varying-ness is unbound. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00149">149</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l00085">Variability::GetString()</a>, <a class="el" href="type_8h_source.html#l00067">Variability::type</a>, and <a class="el" href="type_8h_source.html#l00054">Variability::Unbound</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01895">StructType::checkIfCanBeSOA()</a>, <a class="el" href="type_8cpp_source.html#l00633">EnumType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l01688">StructType::GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l02117">ReferenceType::GetAsUnboundVariabilityType()</a>, <a class="el" href="expr_8cpp_source.html#l06878">TypeCastExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l06859">TypeCastExpr::GetType()</a>, and <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a3e279c313a458cd11804cc000c5591ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e279c313a458cd11804cc000c5591ad">&#9670;&nbsp;</a></span>IsArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a array type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00163">163</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l01557">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="ae563a2978af2027bf5fc50211758f1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae563a2978af2027bf5fc50211758f1d8">&#9670;&nbsp;</a></span>IsBasicType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsBasicType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given type is an atomic, enum, or pointer type (i.e. not an aggregation of multiple instances of a type or types.) </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02762">2762</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03253">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l00936">PointerType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l03977">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l02114">lFinalSliceOffset()</a>, <a class="el" href="expr_8cpp_source.html#l00779">lMatchingBoolType()</a>, <a class="el" href="ctx_8cpp_source.html#l02464">FunctionEmitContext::maskedStore()</a>, <a class="el" href="ctx_8cpp_source.html#l02569">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02754">FunctionEmitContext::storeUniformToSOA()</a>, and <a class="el" href="stmt_8cpp_source.html#l02101">ForeachUniqueStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a38ff6178597171c11f6e24566b251dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ff6178597171c11f6e24566b251dea">&#9670;&nbsp;</a></span>IsBoolType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a3a887eab839163f0e46f85e191bec774">FunctionType</a>, <a class="el" href="classReferenceType.html#a435acf474cd7f427869d561c00329fc3">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#aec3e05aa477649bf96aae0736fc0d035">UndefinedStructType</a>, <a class="el" href="classStructType.html#ab1246328e103c3f7a9607312c04d2373">StructType</a>, <a class="el" href="classVectorType.html#a94129dfe83055573fe59daada2e9bb56">VectorType</a>, <a class="el" href="classArrayType.html#a491e2018080a9c132bd28c41b1eeea2f">ArrayType</a>, <a class="el" href="classPointerType.html#af2af433bd10a91990de4947ccd258ed6">PointerType</a>, <a class="el" href="classEnumType.html#a7f076cc8a13f3be70ecdee4f436f605f">EnumType</a>, and <a class="el" href="classAtomicType.html#af4118c3b7edde83f45fa7ec14be63e08">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l02442">FunctionEmitContext::AllocaInst()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02047">ReferenceType::IsBoolType()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="ctx_8cpp_source.html#l02071">FunctionEmitContext::LoadInst()</a>, <a class="el" href="expr_8cpp_source.html#l06518">lUniformValueToVarying()</a>, <a class="el" href="ctx_8cpp_source.html#l02569">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02674">FunctionEmitContext::StoreInst()</a>, and <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a9a6d77fb89abc534e2ee1726cc13cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6d77fb89abc534e2ee1726cc13cf05">&#9670;&nbsp;</a></span>IsConstType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#ab5fa14aa23184b740f9b229f08478b6b">FunctionType</a>, <a class="el" href="classReferenceType.html#a06ca36217537aa7bd76c3581a6f019d3">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a5df79c1041f69352788fc561ab0b6d0e">UndefinedStructType</a>, <a class="el" href="classStructType.html#a0e2b96684c79f2a4fcad9b1e87e37916">StructType</a>, <a class="el" href="classVectorType.html#a21bd79dacef201d2227bbddc25f3a0b6">VectorType</a>, <a class="el" href="classArrayType.html#a51fc9554e2304d9ed0ec9c3ca2da37ff">ArrayType</a>, <a class="el" href="classPointerType.html#a219727f6f17e8c9c741e9deb39c3afb7">PointerType</a>, <a class="el" href="classEnumType.html#a9fd321015dc46865b005915a67441b80">EnumType</a>, and <a class="el" href="classAtomicType.html#a8a532b43b5ff28c72b189bc6d73089aa">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00272">Module::AddGlobalVariable()</a>, <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="stmt_8cpp_source.html#l00111">DeclStmt::EmitCode()</a>, <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="type_8cpp_source.html#l01106">ArrayType::IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l02079">ReferenceType::IsConstType()</a>, <a class="el" href="expr_8cpp_source.html#l02951">lCheckForConstStructMember()</a>, <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="stmt_8cpp_source.html#l00235">DeclStmt::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l01197">UnaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02976">AssignExpr::TypeCheck()</a>, and <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="aeee9fe8b11fc75a300cf37f8b5c9f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee9fe8b11fc75a300cf37f8b5c9f034">&#9670;&nbsp;</a></span>IsFloatType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#ad41c42b12ccb6301b594591559a9a3da">FunctionType</a>, <a class="el" href="classReferenceType.html#a4398440daeeb8bad7d5eb351cc1c9886">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a62b63f3e7d31354081db38f9907d999e">UndefinedStructType</a>, <a class="el" href="classStructType.html#a1bd61a6a0ef7932e65ad24323f407215">StructType</a>, <a class="el" href="classVectorType.html#a9fa6576b15d69d22a62e268f335cc706">VectorType</a>, <a class="el" href="classArrayType.html#aa6e7926a5b6be820d997e53ab996209c">ArrayType</a>, <a class="el" href="classPointerType.html#a7cd75f6c08fc23632b07b719f7f6f2fe">PointerType</a>, <a class="el" href="classEnumType.html#ae0eecc644346d694aa5ddd321f9d0695">EnumType</a>, and <a class="el" href="classAtomicType.html#af266f218b5ed6f09eb1740da39886f9c">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02055">ReferenceType::IsFloatType()</a>, <a class="el" href="expr_8cpp_source.html#l01468">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01523">lEmitBinaryCmp()</a>, <a class="el" href="expr_8cpp_source.html#l01009">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l00944">lEmitPrePostIncDec()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02976">AssignExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a3b2b570093e27170d582b67211dd6836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2b570093e27170d582b67211dd6836">&#9670;&nbsp;</a></span>IsIntType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a82e2091391eb489dc21b877679e417d6">FunctionType</a>, <a class="el" href="classReferenceType.html#a5123bdab7765916c314067e7378e3a63">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a09e21047993b7fd308215a8a0377c2c7">UndefinedStructType</a>, <a class="el" href="classStructType.html#a9bdaccdd2ec3f52fbb474bf89ca196e5">StructType</a>, <a class="el" href="classVectorType.html#aa92a937cf9ee731f4a649bc9d2b58ce6">VectorType</a>, <a class="el" href="classArrayType.html#ab1b4e85a1d095813d5fecfc00c4387bd">ArrayType</a>, <a class="el" href="classPointerType.html#a7f053c397dc72c63c796feeb6f340956">PointerType</a>, <a class="el" href="classEnumType.html#acf40f261f54f2d7f2ffc9d84d452717d">EnumType</a>, and <a class="el" href="classAtomicType.html#acf17c4ef9795062d45e1d142d6db543e">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l02063">ReferenceType::IsIntType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l01009">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l00154">lIsAllIntZeros()</a>, <a class="el" href="expr_8cpp_source.html#l01197">UnaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a0bb1aee1040dc1ce32d258e221dda18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb1aee1040dc1ce32d258e221dda18f">&#9670;&nbsp;</a></span>IsNumericType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsNumericType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a float or integer type. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00128">128</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01197">UnaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a66b6da2bd1b9074f54cafd4f7cb33639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6da2bd1b9074f54cafd4f7cb33639">&#9670;&nbsp;</a></span>IsPointerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsPointerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is either a pointer type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00161">161</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="expr_8cpp_source.html#l03587">FunctionCallExpr::GetLValueType()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="module_8cpp_source.html#l02096">lGetVaryingDispatchType()</a>, <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l01557">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="aa3196bfa8171b3e14a1b4785725b58aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3196bfa8171b3e14a1b4785725b58aa">&#9670;&nbsp;</a></span>IsReferenceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsReferenceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is a array type </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00165">165</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l01388">emitOffloadParamStruct()</a>, <a class="el" href="expr_8cpp_source.html#l03587">FunctionCallExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l00779">lMatchingBoolType()</a>, and <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>.</p>

</div>
</div>
<a id="a648c0b710985f4bc05102e5ca7b25f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c0b710985f4bc05102e5ca7b25f3f">&#9670;&nbsp;</a></span>IsSOAType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsSOAType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the type is laid out in "structure of arrays" layout. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00141">141</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00054">Variability::SOA</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01462">VectorType::GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l04297">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04121">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="type_8cpp_source.html#l01491">VectorType::getVectorMemoryCount()</a>, <a class="el" href="decl_8cpp_source.html#l00326">Declarator::InitFromType()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l07073">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04221">lConvertPtrToSliceIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l01420">lGetVectorLLVMType()</a>, and <a class="el" href="expr_8cpp_source.html#l01197">UnaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="a86ae2574080628114a510e26582a2e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ae2574080628114a510e26582a2e2a">&#9670;&nbsp;</a></span>IsUniformType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is uniform </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00134">134</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00054">Variability::Uniform</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l01951">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="module_8cpp_source.html#l00549">Module::AddFunctionDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01895">StructType::checkIfCanBeSOA()</a>, <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l05097">ConstExpr::ConstExpr()</a>, <a class="el" href="ctx_8cpp_source.html#l01055">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="decl_8cpp_source.html#l00129">DeclSpecs::DeclSpecs()</a>, <a class="el" href="stmt_8cpp_source.html#l00111">DeclStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00372">IfStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00758">DoStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00922">ForStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02420">ReturnStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02280">SwitchStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02790">AssertStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l02850">DeleteStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00455">IfStmt::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l00894">DoStmt::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l01067">ForStmt::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l03730">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02268">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l00603">EnumType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01680">StructType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l02107">ReferenceType::GetAsUniformType()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l01462">VectorType::GetDIType()</a>, <a class="el" href="ctx_8cpp_source.html#l01825">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04297">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04548">StructMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04697">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="decl_8cpp_source.html#l00669">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l04121">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07272">PtrDerefExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04663">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03126">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04736">VectorMemberExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01491">VectorType::getVectorMemoryCount()</a>, <a class="el" href="expr_8cpp_source.html#l03977">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="ast_8cpp_source.html#l00280">lCheckAllOffSafety()</a>, <a class="el" href="type_8cpp_source.html#l02767">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l02053">lConstFoldBinaryLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l07073">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01387">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01631">lEmitLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l00944">lEmitPrePostIncDec()</a>, <a class="el" href="module_8cpp_source.html#l01171">lEmitVectorTypedefs()</a>, <a class="el" href="stmt_8cpp_source.html#l02608">lEncodeType()</a>, <a class="el" href="ctx_8cpp_source.html#l02114">lFinalSliceOffset()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03781">lGetExprListConstant()</a>, <a class="el" href="type_8cpp_source.html#l01420">lGetVectorLLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l01857">lIsDifficultShiftAmount()</a>, <a class="el" href="expr_8cpp_source.html#l07740">lIsMatchWithTypeWidening()</a>, <a class="el" href="expr_8cpp_source.html#l00794">lLLVMConstantValue()</a>, <a class="el" href="expr_8cpp_source.html#l00779">lMatchingBoolType()</a>, <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::LoadInst()</a>, <a class="el" href="stmt_8cpp_source.html#l02650">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l06018">lTypeConvAtomic()</a>, <a class="el" href="expr_8cpp_source.html#l06518">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l04011">lVaryingStructHasUniformMember()</a>, <a class="el" href="ctx_8cpp_source.html#l02464">FunctionEmitContext::maskedStore()</a>, <a class="el" href="ctx_8cpp_source.html#l02569">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02708">FunctionEmitContext::StoreInst()</a>, <a class="el" href="stmt_8cpp_source.html#l00440">IfStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00866">DoStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01051">ForStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03604">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04361">IndexExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02333">SwitchStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02831">AssertStmt::TypeCheck()</a>.</p>

</div>
</div>
<a id="a9fb5648ec4eb5b432723cf0b3332f8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb5648ec4eb5b432723cf0b3332f8d0">&#9670;&nbsp;</a></span>IsUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a03fb956fe09ef7e7135c85e4615ced1d">FunctionType</a>, <a class="el" href="classReferenceType.html#a3dc68bc21149ca626b5368d567acf39e">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a43b8505d75d3a4e012efc82c91fe3652">UndefinedStructType</a>, <a class="el" href="classStructType.html#a592b363f12395e5ab86f66743b0d25ea">StructType</a>, <a class="el" href="classVectorType.html#a272cd03d941b5bb22dd22d7c26572722">VectorType</a>, <a class="el" href="classArrayType.html#a66ec44ebec01ec45f9e6d8cf94c6e0b8">ArrayType</a>, <a class="el" href="classPointerType.html#a700bd9930b41e22d8bf67a373575e30d">PointerType</a>, <a class="el" href="classEnumType.html#aa70c13644ae1af00f2d81a5cc7071b05">EnumType</a>, and <a class="el" href="classAtomicType.html#aaafe84a7199bf47ecc8ab4f2b550339f">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01885">BinaryExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02071">ReferenceType::IsUnsignedType()</a>, <a class="el" href="expr_8cpp_source.html#l01468">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01523">lEmitBinaryCmp()</a>, and <a class="el" href="expr_8cpp_source.html#l02792">lEmitOpAssign()</a>.</p>

</div>
</div>
<a id="a6f3d0d94b1f26a6e62d5d4cf78f1c254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3d0d94b1f26a6e62d5d4cf78f1c254">&#9670;&nbsp;</a></span>IsVaryingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is varying </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00137">137</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00054">Variability::Varying</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l03253">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="expr_8cpp_source.html#l07817">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l05822">ConstExpr::Count()</a>, <a class="el" href="decl_8cpp_source.html#l00129">DeclSpecs::DeclSpecs()</a>, <a class="el" href="expr_8cpp_source.html#l04426">IndexExpr::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l04970">MemberExpr::EstimateCost()</a>, <a class="el" href="stmt_8cpp_source.html#l02364">SwitchStmt::EstimateCost()</a>, <a class="el" href="expr_8cpp_source.html#l07306">PtrDerefExpr::EstimateCost()</a>, <a class="el" href="ctx_8cpp_source.html#l02268">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l00623">EnumType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01672">StructType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l02097">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="decl_8cpp_source.html#l00147">DeclSpecs::GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l00936">PointerType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01226">ArrayType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02392">FunctionType::GetCDeclarationForDispatch()</a>, <a class="el" href="expr_8cpp_source.html#l07572">SizeOfExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01462">VectorType::GetDIType()</a>, <a class="el" href="ctx_8cpp_source.html#l01825">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04297">IndexExpr::GetLValueType()</a>, <a class="el" href="decl_8cpp_source.html#l00669">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l01936">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03247">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04503">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04663">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03446">FunctionCallExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04062">IndexExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l05303">ConstExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01491">VectorType::getVectorMemoryCount()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l03977">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="module_8cpp_source.html#l01019">lContainsPtrToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l07073">lConvertPointerConstant()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01468">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l01523">lEmitBinaryCmp()</a>, <a class="el" href="expr_8cpp_source.html#l01387">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01631">lEmitLogicalOp()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03781">lGetExprListConstant()</a>, <a class="el" href="module_8cpp_source.html#l02096">lGetVaryingDispatchType()</a>, <a class="el" href="type_8cpp_source.html#l01420">lGetVectorLLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l01857">lIsDifficultShiftAmount()</a>, <a class="el" href="stmt_8cpp_source.html#l00697">lIsVaryingFor()</a>, <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::LoadInst()</a>, <a class="el" href="module_8cpp_source.html#l00465">lRecursiveCheckValidParamType()</a>, <a class="el" href="expr_8cpp_source.html#l06018">lTypeConvAtomic()</a>, <a class="el" href="expr_8cpp_source.html#l06518">lUniformValueToVarying()</a>, <a class="el" href="expr_8cpp_source.html#l04011">lVaryingStructHasUniformMember()</a>, <a class="el" href="ctx_8cpp_source.html#l02464">FunctionEmitContext::maskedStore()</a>, <a class="el" href="type_8cpp_source.html#l02602">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l03281">SelectExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l06973">TypeCastExpr::Optimize()</a>, <a class="el" href="ctx_8cpp_source.html#l02569">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02708">FunctionEmitContext::StoreInst()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02976">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03349">SelectExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03604">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l02101">ForeachUniqueStmt::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l08247">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="aa89dbc6fd641f5538ebc4351b30d7717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89dbc6fd641f5538ebc4351b30d7717">&#9670;&nbsp;</a></span>IsVoidType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsVoidType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the underlying type is either a pointer or an array </p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00167">167</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l02855">EqualIgnoringConst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00549">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00272">Module::AddGlobalVariable()</a>, <a class="el" href="type_8cpp_source.html#l01074">ArrayType::ArrayType()</a>, <a class="el" href="ctx_8cpp_source.html#l01055">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="func_8cpp_source.html#l00200">Function::emitCode()</a>, <a class="el" href="ctx_8cpp_source.html#l00199">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="decl_8cpp_source.html#l00669">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l03446">FunctionCallExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00613">Declaration::GetVariableDeclarations()</a>, <a class="el" href="decl_8cpp_source.html#l00326">Declarator::InitFromType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00175">lDoTypeConv()</a>, <a class="el" href="type_8cpp_source.html#l02476">FunctionType::LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l00983">PointerType::LLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l03604">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>, <a class="el" href="module_8cpp_source.html#l01422">Module::writeDevStub()</a>, and <a class="el" href="module_8cpp_source.html#l01557">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="ab311bc549bbf9b4a1136a78eb276897c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab311bc549bbf9b4a1136a78eb276897c">&#9670;&nbsp;</a></span>LLVMStorageType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Type::LLVMStorageType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the LLVM storage type corresponding to this ispc type. </p>

<p>Reimplemented in <a class="el" href="classVectorType.html#acbdd708a407f09382dcae4f8402f159b">VectorType</a>, and <a class="el" href="classAtomicType.html#a5a176096239f121ce00c04bc3cb0de15">AtomicType</a>.</p>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l00125">125</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00306">AtomicType::TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00316">AtomicType::TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00313">AtomicType::TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00309">AtomicType::TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00311">AtomicType::TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00314">AtomicType::TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00307">AtomicType::TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00310">AtomicType::TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00312">AtomicType::TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00315">AtomicType::TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00308">AtomicType::TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00054">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00322">AtomicType::UniformBool</a>, <a class="el" href="type_8h_source.html#l00332">AtomicType::UniformDouble</a>, <a class="el" href="type_8h_source.html#l00329">AtomicType::UniformFloat</a>, <a class="el" href="type_8h_source.html#l00324">AtomicType::UniformInt16</a>, <a class="el" href="type_8h_source.html#l00325">AtomicType::UniformInt32</a>, <a class="el" href="type_8h_source.html#l00330">AtomicType::UniformInt64</a>, <a class="el" href="type_8h_source.html#l00323">AtomicType::UniformInt8</a>, <a class="el" href="type_8h_source.html#l00327">AtomicType::UniformUInt16</a>, <a class="el" href="type_8h_source.html#l00328">AtomicType::UniformUInt32</a>, <a class="el" href="type_8h_source.html#l00331">AtomicType::UniformUInt64</a>, <a class="el" href="type_8h_source.html#l00326">AtomicType::UniformUInt8</a>, <a class="el" href="type_8h_source.html#l00054">Variability::Varying</a>, <a class="el" href="type_8h_source.html#l00322">AtomicType::VaryingBool</a>, <a class="el" href="type_8h_source.html#l00332">AtomicType::VaryingDouble</a>, <a class="el" href="type_8h_source.html#l00329">AtomicType::VaryingFloat</a>, <a class="el" href="type_8h_source.html#l00324">AtomicType::VaryingInt16</a>, <a class="el" href="type_8h_source.html#l00325">AtomicType::VaryingInt32</a>, <a class="el" href="type_8h_source.html#l00330">AtomicType::VaryingInt64</a>, <a class="el" href="type_8h_source.html#l00323">AtomicType::VaryingInt8</a>, <a class="el" href="type_8h_source.html#l00327">AtomicType::VaryingUInt16</a>, <a class="el" href="type_8h_source.html#l00328">AtomicType::VaryingUInt32</a>, <a class="el" href="type_8h_source.html#l00331">AtomicType::VaryingUInt64</a>, <a class="el" href="type_8h_source.html#l00326">AtomicType::VaryingUInt8</a>, and <a class="el" href="type_8h_source.html#l00333">AtomicType::Void</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00272">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l02442">FunctionEmitContext::AllocaInst()</a>, <a class="el" href="type_8cpp_source.html#l01820">StructType::GetDIType()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00594">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l03092">lEmitVaryingSelect()</a>, <a class="el" href="type_8cpp_source.html#l01420">lGetVectorLLVMType()</a>, <a class="el" href="type_8cpp_source.html#l00983">PointerType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01080">ArrayType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l02220">ReferenceType::LLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l06518">lUniformValueToVarying()</a>, <a class="el" href="ctx_8cpp_source.html#l02674">FunctionEmitContext::StoreInst()</a>, and <a class="el" href="type_8cpp_source.html#l01568">StructType::StructType()</a>.</p>

</div>
</div>
<a id="a04eb42d850a697fc181b388688b6393e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eb42d850a697fc181b388688b6393e">&#9670;&nbsp;</a></span>LLVMType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* Type::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#aef3fdfb9cec80336002d392c9669b0ed">FunctionType</a>, <a class="el" href="classReferenceType.html#a4c011e2d150892da354f34b1c8f80832">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#ab76b7d9531557c59f4718a5541fddfbf">UndefinedStructType</a>, <a class="el" href="classStructType.html#a5ec4d8d16e49b70a94dc92da5c515137">StructType</a>, <a class="el" href="classVectorType.html#aaac5086159ec7d6558923dde03c48b53">VectorType</a>, <a class="el" href="classArrayType.html#a5a75acce8544c68388bdacb88f8f4459">ArrayType</a>, <a class="el" href="classPointerType.html#a57c6f4a639279fb4d41dbe8dae229ab1">PointerType</a>, <a class="el" href="classEnumType.html#a4ff26311dc903b2f2b9f44cc977ee871">EnumType</a>, and <a class="el" href="classAtomicType.html#a81f5374d2a68d9e29ac1983075a6d488">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="ctx_8cpp_source.html#l01951">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="ctx_8cpp_source.html#l03253">FunctionEmitContext::addVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l02442">FunctionEmitContext::AllocaInst()</a>, <a class="el" href="ctx_8cpp_source.html#l01693">FunctionEmitContext::applyVaryingGEP()</a>, <a class="el" href="ctx_8cpp_source.html#l02975">FunctionEmitContext::CallInst()</a>, <a class="el" href="stmt_8cpp_source.html#l00111">DeclStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l01918">ForeachUniqueStmt::EmitCode()</a>, <a class="el" href="ctx_8cpp_source.html#l02268">FunctionEmitContext::gather()</a>, <a class="el" href="expr_8cpp_source.html#l07095">TypeCastExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07462">AddressOfExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07572">SizeOfExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l08075">NullPointerExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03126">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06567">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l07140">ReferenceExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l07526">SizeOfExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l08125">NewExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l01387">lEmitBinaryPointerArith()</a>, <a class="el" href="expr_8cpp_source.html#l01009">lEmitNegate()</a>, <a class="el" href="module_8cpp_source.html#l01036">lEmitStructDecl()</a>, <a class="el" href="expr_8cpp_source.html#l05824">lGetConstExprConstant()</a>, <a class="el" href="expr_8cpp_source.html#l03781">lGetExprListConstant()</a>, <a class="el" href="type_8cpp_source.html#l01420">lGetVectorLLVMType()</a>, <a class="el" href="type_8cpp_source.html#l02476">FunctionType::LLVMFunctionType()</a>, <a class="el" href="ctx_8cpp_source.html#l02071">FunctionEmitContext::LoadInst()</a>, and <a class="el" href="ctx_8cpp_source.html#l02143">FunctionEmitContext::loadUniformFromSOA()</a>.</p>

</div>
</div>
<a id="a7bd23bd909d493d271dbe1024d212c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd23bd909d493d271dbe1024d212c06">&#9670;&nbsp;</a></span>Mangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implemented in <a class="el" href="classFunctionType.html#a7a6fc9c1807d33b2273e300183405c53">FunctionType</a>, <a class="el" href="classReferenceType.html#aadda98c0786cb5d5f07c76aca77b92f2">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#a83413ab3803c932e8a15e29476b2240b">UndefinedStructType</a>, <a class="el" href="classStructType.html#a647ea56c99fb03cf8d62e7105b0da8d1">StructType</a>, <a class="el" href="classVectorType.html#a75a7e452d76081308f343698f2efe517">VectorType</a>, <a class="el" href="classArrayType.html#a5ced9573ec1451fedf707f7fe12970a0">ArrayType</a>, <a class="el" href="classPointerType.html#ad8646c014d8d04358b1e8880f7945fe8">PointerType</a>, <a class="el" href="classEnumType.html#abc453044eabe7c4fef642310697588c6">EnumType</a>, and <a class="el" href="classAtomicType.html#a9060ce0a4e6858cf6b406a13841ae023">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l00917">PointerType::Mangle()</a>, <a class="el" href="type_8cpp_source.html#l01211">ArrayType::Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l02182">ReferenceType::Mangle()</a>.</p>

</div>
</div>
<a id="a078b7dc77c288701d13abaa57434da91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078b7dc77c288701d13abaa57434da91">&#9670;&nbsp;</a></span>MoreGeneralType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::MoreGeneralType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceVarying</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vecSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given two types, returns the least general <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> that is more general than both of them. (i.e. that can represent their values without any loss of data.) If there is no such <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a>, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type0</td><td>First of the two types </td></tr>
    <tr><td class="paramname">type1</td><td>Second of the two types </td></tr>
    <tr><td class="paramname">pos</td><td>Source file position where the general type is needed. </td></tr>
    <tr><td class="paramname">reason</td><td>String describing the context of why the general type is needed (e.g. "+ operator"). </td></tr>
    <tr><td class="paramname">forceVarying</td><td>If <code>true</code>, then make sure that the returned type is "varying". </td></tr>
    <tr><td class="paramname">vecSize</td><td>The vector size of the returned type. If non-zero, the returned type will be a <a class="el" href="classVectorType.html" title="A (short) vector of atomic types. ">VectorType</a> of the more general type with given length. If zero, this parameter has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The more general type, based on the provided parameters.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>the vecSize and forceVarying parts of this should probably be factored out and done separately in the cases when needed.</dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cpp_source.html#l02602">2602</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8h_source.html#l00128">Assert</a>, <a class="el" href="type_8cpp_source.html#l02853">Equal()</a>, <a class="el" href="type_8cpp_source.html#l02855">EqualIgnoringConst()</a>, <a class="el" href="util_8cpp_source.html#l00351">Error()</a>, <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType()</a>, <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01416">VectorType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01418">VectorType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l02564">GetReferenceTarget()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00799">PointerType::GetUniform()</a>, <a class="el" href="type_8h_source.html#l00137">IsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00807">PointerType::IsVoidPointer()</a>, <a class="el" href="type_8cpp_source.html#l02578">lVectorConvert()</a>, <a class="el" href="type_8h_source.html#l00328">AtomicType::UniformUInt32</a>, and <a class="el" href="type_8h_source.html#l00328">AtomicType::VaryingUInt32</a>.</p>

<p class="reference">Referenced by <a class="el" href="expr_8cpp_source.html#l01936">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03247">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l01631">lEmitLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l02327">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l03349">SelectExpr::TypeCheck()</a>.</p>

</div>
</div>
<a id="adced497622fac125548ef5531495c738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adced497622fac125548ef5531495c738">&#9670;&nbsp;</a></span>ResolveUnboundVariability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classFunctionType.html#ac58b8ce12713fbb1c7eb045d0abe52ae">FunctionType</a>, <a class="el" href="classReferenceType.html#a73ebfde46e11e757f0dfba2e8c3958f4">ReferenceType</a>, <a class="el" href="classUndefinedStructType.html#afdff99026f49418a91a525b32e4bfccd">UndefinedStructType</a>, <a class="el" href="classStructType.html#a0be3702eaa8cbc4763bcf7fcbf354430">StructType</a>, <a class="el" href="classVectorType.html#aa8c03bd14a72ad6cbfc4ff3d672970e0">VectorType</a>, <a class="el" href="classArrayType.html#a5003644da005409e118e5e23dd68cd40">ArrayType</a>, <a class="el" href="classPointerType.html#a68ee39f760b455d80308768c378a097a">PointerType</a>, <a class="el" href="classEnumType.html#a94336c07b0774a2459eb96680ac6f734">EnumType</a>, and <a class="el" href="classAtomicType.html#ae31d7814a357e0cec755015d148e6a24">AtomicType</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8cpp_source.html#l01859">StructType::GetElementType()</a>, <a class="el" href="expr_8cpp_source.html#l06859">TypeCastExpr::GetType()</a>, <a class="el" href="decl_8cpp_source.html#l00613">Declaration::GetVariableDeclarations()</a>, <a class="el" href="decl_8cpp_source.html#l00326">Declarator::InitFromType()</a>, <a class="el" href="decl_8cpp_source.html#l00074">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l08099">NewExpr::NewExpr()</a>, <a class="el" href="type_8cpp_source.html#l00871">PointerType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l01151">ArrayType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l02132">ReferenceType::ResolveUnboundVariability()</a>, <a class="el" href="type_8cpp_source.html#l02306">FunctionType::ResolveUnboundVariability()</a>, <a class="el" href="expr_8cpp_source.html#l07522">SizeOfExpr::SizeOfExpr()</a>, and <a class="el" href="expr_8cpp_source.html#l06895">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1d91eeddf01faa36a8cccddb5bb2a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d91eeddf01faa36a8cccddb5bb2a06">&#9670;&nbsp;</a></span>typeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> Type::typeId</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates which <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> implementation this type is. This value can be used to determine the actual type much more efficiently than using dynamic_cast. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00256">256</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="type_8h_source.html#l00931">CastType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 24 2020 00:01:25 for Intel速 Implicit SPMD Program Compiler (Intel速 ISPC) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
