<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel SPMD Program Compiler: SymbolTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSymbolTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SymbolTable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a> table that holds all known symbols during parsing and compilation.  
 <a href="classSymbolTable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sym_8h_source.html">sym.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for SymbolTable:</div>
<div class="dyncontent">
<div class="center"><img src="classSymbolTable__coll__graph.png" border="0" usemap="#SymbolTable_coll__map" alt="Collaboration graph"/></div>
<map name="SymbolTable_coll__map" id="SymbolTable_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fbe6cec5594463b766db0ac58c9aa1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a1fbe6cec5594463b766db0ac58c9aa1d">SymbolTable</a> ()</td></tr>
<tr class="separator:a1fbe6cec5594463b766db0ac58c9aa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5ae9b5b22d87691cec9ec17cfff650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a5d5ae9b5b22d87691cec9ec17cfff650">~SymbolTable</a> ()</td></tr>
<tr class="separator:a5d5ae9b5b22d87691cec9ec17cfff650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8daa1cf8667258e065b8be95facb330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ae8daa1cf8667258e065b8be95facb330">PushScope</a> ()</td></tr>
<tr class="separator:ae8daa1cf8667258e065b8be95facb330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79caf59c28df4805abaf2ce5df83198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aa79caf59c28df4805abaf2ce5df83198">PopScope</a> ()</td></tr>
<tr class="separator:aa79caf59c28df4805abaf2ce5df83198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5e4d85d5e1ede45b7fd155741628ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a2d5e4d85d5e1ede45b7fd155741628ff">AddVariable</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr class="separator:a2d5e4d85d5e1ede45b7fd155741628ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89545a31f6a562bb10089b79fa5c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a4c89545a31f6a562bb10089b79fa5c08">LookupVariable</a> (const char *name)</td></tr>
<tr class="separator:a4c89545a31f6a562bb10089b79fa5c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49a5dd3c4f49a5c1a2b7882dd1af736"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ab49a5dd3c4f49a5c1a2b7882dd1af736">AddFunction</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr class="separator:ab49a5dd3c4f49a5c1a2b7882dd1af736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb30e239525741115ed5f81392a09b3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#afb30e239525741115ed5f81392a09b3b">LookupFunction</a> (const char *name, std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *matches=NULL)</td></tr>
<tr class="separator:afb30e239525741115ed5f81392a09b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e77310132f022532a016e6fe1e127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a716e77310132f022532a016e6fe1e127">LookupFunction</a> (const char *name, const <a class="el" href="classFunctionType.html">FunctionType</a> *type)</td></tr>
<tr class="separator:a716e77310132f022532a016e6fe1e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f084deaf36f7ed23f3cb48cfa05316c"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a2f084deaf36f7ed23f3cb48cfa05316c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a2f084deaf36f7ed23f3cb48cfa05316c">GetMatchingFunctions</a> (Predicate pred, std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *matches) const</td></tr>
<tr class="separator:a2f084deaf36f7ed23f3cb48cfa05316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f4729b9315d000c6c4e6af052c2005"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:ad4f4729b9315d000c6c4e6af052c2005"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ad4f4729b9315d000c6c4e6af052c2005">GetMatchingVariables</a> (Predicate pred, std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *matches) const</td></tr>
<tr class="separator:ad4f4729b9315d000c6c4e6af052c2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab449fbe2b55797a074940394467a262e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ab449fbe2b55797a074940394467a262e">AddType</a> (const char *name, const <a class="el" href="classType.html">Type</a> *type, <a class="el" href="structSourcePos.html">SourcePos</a> pos)</td></tr>
<tr class="separator:ab449fbe2b55797a074940394467a262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78ee545db851130be4ac7f2ed3fa259"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aa78ee545db851130be4ac7f2ed3fa259">LookupType</a> (const char *name) const</td></tr>
<tr class="separator:aa78ee545db851130be4ac7f2ed3fa259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69cd1019fae50d172ace245d2fc748f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ad69cd1019fae50d172ace245d2fc748f">ContainsType</a> (const <a class="el" href="classType.html">Type</a> *type) const</td></tr>
<tr class="separator:ad69cd1019fae50d172ace245d2fc748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d86f2289fc8dfe57da4cf95f423458"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ab7d86f2289fc8dfe57da4cf95f423458">ClosestVariableOrFunctionMatch</a> (const char *name) const</td></tr>
<tr class="separator:ab7d86f2289fc8dfe57da4cf95f423458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc7220e1b4cb899804b4afbd9417679"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a3bc7220e1b4cb899804b4afbd9417679">ClosestTypeMatch</a> (const char *name) const</td></tr>
<tr class="separator:a3bc7220e1b4cb899804b4afbd9417679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3611768802999b11f50fc4a4e2c490"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ace3611768802999b11f50fc4a4e2c490">ClosestEnumTypeMatch</a> (const char *name) const</td></tr>
<tr class="separator:ace3611768802999b11f50fc4a4e2c490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642684baa5464f91821d8a83595bb7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a6642684baa5464f91821d8a83595bb7b">Print</a> ()</td></tr>
<tr class="separator:a6642684baa5464f91821d8a83595bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2502ae8d176fc65f5f3f35a74e8c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a8d2502ae8d176fc65f5f3f35a74e8c50">RandomSymbol</a> ()</td></tr>
<tr class="separator:a8d2502ae8d176fc65f5f3f35a74e8c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa882da18fadc3eaedb33c9e6fe0de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#abffa882da18fadc3eaedb33c9e6fe0de">RandomType</a> ()</td></tr>
<tr class="separator:abffa882da18fadc3eaedb33c9e6fe0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aef2544e5039654a9583a927e73995d1b"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classSymbol.html">Symbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolMapType</a></td></tr>
<tr class="separator:aef2544e5039654a9583a927e73995d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ca48a60a649d7fb9acf4dbf216dbd"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a572ca48a60a649d7fb9acf4dbf216dbd">FunctionMapType</a></td></tr>
<tr class="separator:a572ca48a60a649d7fb9acf4dbf216dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c3d3253785b20285973345d1ebda6c"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, const <a class="el" href="classType.html">Type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a></td></tr>
<tr class="separator:a03c3d3253785b20285973345d1ebda6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7a174dfc00172f3055e72b801fc82b46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a7a174dfc00172f3055e72b801fc82b46">closestTypeMatch</a> (const char *str, bool structsVsEnums) const</td></tr>
<tr class="separator:a7a174dfc00172f3055e72b801fc82b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aabcd388428ccc659020d47e9cb441606"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolMapType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aabcd388428ccc659020d47e9cb441606">variables</a></td></tr>
<tr class="separator:aabcd388428ccc659020d47e9cb441606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f0654be5acf123bb1361b70254a820"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolMapType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a54f0654be5acf123bb1361b70254a820">freeSymbolMaps</a></td></tr>
<tr class="separator:a54f0654be5acf123bb1361b70254a820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9ed3c8090d2ef62ec1af29c7980848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolTable.html#a572ca48a60a649d7fb9acf4dbf216dbd">FunctionMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a6a9ed3c8090d2ef62ec1af29c7980848">functions</a></td></tr>
<tr class="separator:a6a9ed3c8090d2ef62ec1af29c7980848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958f9beda85202e291efe9816a0cd717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a958f9beda85202e291efe9816a0cd717">types</a></td></tr>
<tr class="separator:a958f9beda85202e291efe9816a0cd717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a> table that holds all known symbols during parsing and compilation. </p>
<p>A single instance of a <a class="el" href="classSymbolTable.html" title="Symbol table that holds all known symbols during parsing and compilation. ">SymbolTable</a> is stored in the <a class="el" href="classModule.html">Module</a> class (<a class="el" href="classModule.html#a66a01f1bae4f9c26eb1bc95780865954">Module::symbolTable</a>); it is created in the <a class="el" href="classModule.html#a4eff728447dea74aa9bfb0de65c6d0a4">Module::Module()</a> constructor. It is then accessed via the global variable <a class="el" href="classModule.html">Module</a> *<a class="el" href="ispc_8cpp.html#a8a689c90deea0b4e040fdede6e79dc95">m</a> throughout the ispc implementation. </p>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00117">117</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a572ca48a60a649d7fb9acf4dbf216dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572ca48a60a649d7fb9acf4dbf216dbd">&#9670;&nbsp;</a></span>FunctionMapType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::vector&lt;<a class="el" href="classSymbol.html">Symbol</a> *&gt; &gt; <a class="el" href="classSymbolTable.html#a572ca48a60a649d7fb9acf4dbf216dbd">SymbolTable::FunctionMapType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> declarations are <em>not</em> scoped. (C99, for example, allows an implementation to maintain function declarations in a single namespace.) A STL <code>vector</code> is used to store the function symbols for a given name since, due to function overloading, a name can have multiple function symbols associated with it. </p>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00268">268</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

</div>
</div>
<a id="aef2544e5039654a9583a927e73995d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2544e5039654a9583a927e73995d1b">&#9670;&nbsp;</a></span>SymbolMapType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classSymbol.html">Symbol</a> *&gt; <a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolTable::SymbolMapType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member variable holds one SymbolMap for each of the current active scopes as the program is being parsed. New maps are added and removed from the end of the main vector, so searches for symbols start looking at the end of <code>variables</code> and work backwards. </p>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00258">258</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

</div>
</div>
<a id="a03c3d3253785b20285973345d1ebda6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c3d3253785b20285973345d1ebda6c">&#9670;&nbsp;</a></span>TypeMapType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, const <a class="el" href="classType.html">Type</a> *&gt; <a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">SymbolTable::TypeMapType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> definitions can't currently be scoped. </p>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00273">273</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1fbe6cec5594463b766db0ac58c9aa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbe6cec5594463b766db0ac58c9aa1d">&#9670;&nbsp;</a></span>SymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolTable::SymbolTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00059">59</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8cpp_source.html#l00067">PushScope()</a>.</p>

</div>
</div>
<a id="a5d5ae9b5b22d87691cec9ec17cfff650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5ae9b5b22d87691cec9ec17cfff650">&#9670;&nbsp;</a></span>~SymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolTable::~SymbolTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00061">61</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="sym_8cpp_source.html#l00079">PopScope()</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab49a5dd3c4f49a5c1a2b7882dd1af736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49a5dd3c4f49a5c1a2b7882dd1af736">&#9670;&nbsp;</a></span>AddFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given function symbol to the symbol table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The function symbol to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the symbol has been added. False if another function symbol with the same name and function signature is already present in the symbol table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00126">126</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="sym_8h_source.html#l00269">functions</a>, <a class="el" href="sym_8cpp_source.html#l00139">LookupFunction()</a>, <a class="el" href="sym_8h_source.html#l00070">Symbol::name</a>, and <a class="el" href="sym_8h_source.html#l00083">Symbol::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="builtins_8cpp_source.html#l00183">lCreateISPCSymbol()</a>, and <a class="el" href="builtins_8cpp_source.html#l00165">lCreateSymbol()</a>.</p>

</div>
</div>
<a id="ab449fbe2b55797a074940394467a262e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab449fbe2b55797a074940394467a262e">&#9670;&nbsp;</a></span>AddType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the named type to the symbol table. This is used for both struct definitions (where <code>struct Foo</code> causes type <code>Foo</code> to be added to the symbol table) as well as for <code>typedef</code>s. For structs with forward declarations ("struct Foo;") and are thus UndefinedStructTypes, this method replaces these with an actual struct definition if one is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the type to be added </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a> that <code>name</code> represents </td></tr>
    <tr><td class="paramname">pos</td><td>Position in source file where the type was named </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the named type was successfully added. False if a type with the same name has already been defined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00165">165</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8cpp_source.html#l00351">Error()</a>, <a class="el" href="sym_8cpp_source.html#l00180">LookupType()</a>, and <a class="el" href="sym_8h_source.html#l00274">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00532">Module::AddTypeDef()</a>, and <a class="el" href="module_8cpp_source.html#l00148">lDeclareSizeAndPtrIntTypes()</a>.</p>

</div>
</div>
<a id="a2d5e4d85d5e1ede45b7fd155741628ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5e4d85d5e1ede45b7fd155741628ff">&#9670;&nbsp;</a></span>AddVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given variable symbol to the symbol table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; false if the provided symbol clashes with a symbol defined at the same scope. (Symbols may shaodow symbols in outer scopes; a warning is issued in this case, but this method still returns true.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00085">85</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="util_8cpp_source.html#l00351">Error()</a>, <a class="el" href="sym_8h_source.html#l00070">Symbol::name</a>, <a class="el" href="sym_8h_source.html#l00069">Symbol::pos</a>, <a class="el" href="sym_8h_source.html#l00259">variables</a>, and <a class="el" href="util_8cpp_source.html#l00375">Warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="decl_8cpp_source.html#l00630">Declaration::GetVariableDeclarations()</a>, <a class="el" href="builtins_8cpp_source.html#l00964">lDefineConstantInt()</a>, <a class="el" href="builtins_8cpp_source.html#l01025">lDefineConstantIntFunc()</a>, and <a class="el" href="builtins_8cpp_source.html#l01046">lDefineProgramIndex()</a>.</p>

</div>
</div>
<a id="ace3611768802999b11f50fc4a4e2c490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3611768802999b11f50fc4a4e2c490">&#9670;&nbsp;</a></span>ClosestEnumTypeMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestEnumTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00238">238</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8cpp_source.html#l00242">closestTypeMatch()</a>.</p>

</div>
</div>
<a id="a3bc7220e1b4cb899804b4afbd9417679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc7220e1b4cb899804b4afbd9417679">&#9670;&nbsp;</a></span>ClosestTypeMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns zero or more strings with the names of types in the symbol table that nearly (but not exactly) match the given name. </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00236">236</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8cpp_source.html#l00242">closestTypeMatch()</a>.</p>

</div>
</div>
<a id="a7a174dfc00172f3055e72b801fc82b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a174dfc00172f3055e72b801fc82b46">&#9670;&nbsp;</a></span>closestTypeMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::closestTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>structsVsEnums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00242">242</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_8cpp_source.html#l00452">StringEditDistance()</a>, and <a class="el" href="sym_8h_source.html#l00274">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00238">ClosestEnumTypeMatch()</a>, and <a class="el" href="sym_8cpp_source.html#l00236">ClosestTypeMatch()</a>.</p>

</div>
</div>
<a id="ab7d86f2289fc8dfe57da4cf95f423458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d86f2289fc8dfe57da4cf95f423458">&#9670;&nbsp;</a></span>ClosestVariableOrFunctionMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestVariableOrFunctionMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns zero or more strings with the names of symbols in the symbol table that nearly (but not exactly) match the given name. This is useful for issuing informative error methods when misspelled identifiers are found a programs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to compare variable and function symbol names against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of zero or more strings that approximately match <code>name</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00199">199</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00269">functions</a>, <a class="el" href="sym_8h_source.html#l00070">Symbol::name</a>, <a class="el" href="util_8cpp_source.html#l00452">StringEditDistance()</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

</div>
</div>
<a id="ad69cd1019fae50d172ace245d2fc748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69cd1019fae50d172ace245d2fc748f">&#9670;&nbsp;</a></span>ContainsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::ContainsType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for a type given a pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>True if found, False otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00188">188</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00274">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="decl_8cpp_source.html#l00129">DeclSpecs::DeclSpecs()</a>.</p>

</div>
</div>
<a id="a2f084deaf36f7ed23f3cb48cfa05316c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f084deaf36f7ed23f3cb48cfa05316c">&#9670;&nbsp;</a></span>GetMatchingFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::GetMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *&#160;</td>
          <td class="paramname"><em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all of the functions in the symbol table that match the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A unary predicate that returns true or false, given a <a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a> pointer, based on whether the symbol should be included in the returned set of matches. It can either be a function, with signature <code>bool pred(const Symbol *s)</code>, or a unary predicate object with an <code>bool operator()(const Symbol *)</code> method.</td></tr>
    <tr><td class="paramname">matches</td><td>Pointer to a vector in which to return the matching symbols. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00278">278</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00269">functions</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l02625">lGetExportedFunctions()</a>, <a class="el" href="module_8cpp_source.html#l01907">Module::writeDevStub()</a>, <a class="el" href="module_8cpp_source.html#l02276">Module::writeDispatchHeader()</a>, <a class="el" href="module_8cpp_source.html#l02160">Module::writeHeader()</a>, and <a class="el" href="module_8cpp_source.html#l02042">Module::writeHostStub()</a>.</p>

</div>
</div>
<a id="ad4f4729b9315d000c6c4e6af052c2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f4729b9315d000c6c4e6af052c2005">&#9670;&nbsp;</a></span>GetMatchingVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::GetMatchingVariables </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *&#160;</td>
          <td class="paramname"><em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all of the variable symbols in the symbol table that match the given predicate. The predicate is defined as in the <a class="el" href="classSymbolTable.html#a2f084deaf36f7ed23f3cb48cfa05316c">GetMatchingFunctions()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00292">292</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

</div>
</div>
<a id="afb30e239525741115ed5f81392a09b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb30e239525741115ed5f81392a09b3b">&#9670;&nbsp;</a></span>LookupFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::LookupFunction </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> *&gt; *&#160;</td>
          <td class="paramname"><em>matches</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for the function or functions with the given name in the symbol name. If a function has been overloaded and multiple definitions are present for a given function name, all of them will be returned in the provided vector and it's up the the caller to resolve which one (if any) to use. Returns true if any matches were found. </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00139">139</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00269">functions</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00126">AddFunction()</a>, <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l01123">Module::AddFunctionDefinition()</a>, <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l01202">FunctionEmitContext::All()</a>, <a class="el" href="ctx_8cpp_source.html#l01187">FunctionEmitContext::Any()</a>, <a class="el" href="ctx_8cpp_source.html#l01234">FunctionEmitContext::LaneMask()</a>, <a class="el" href="expr_8cpp_source.html#l01561">lCreateBinaryOperatorCall()</a>, <a class="el" href="ctx_8cpp_source.html#l02367">FunctionEmitContext::LoadInst()</a>, <a class="el" href="ctx_8cpp_source.html#l01218">FunctionEmitContext::None()</a>, and <a class="el" href="expr_8cpp_source.html#l02186">BinaryExpr::Optimize()</a>.</p>

</div>
</div>
<a id="a716e77310132f022532a016e6fe1e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716e77310132f022532a016e6fe1e127">&#9670;&nbsp;</a></span>LookupFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * SymbolTable::LookupFunction </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionType.html">FunctionType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a function with the given name and type in the symbol table.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to matching <a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a>; NULL if none is found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00153">153</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="type_8cpp_source.html#l03114">Type::Equal()</a>, and <a class="el" href="sym_8h_source.html#l00269">functions</a>.</p>

</div>
</div>
<a id="aa78ee545db851130be4ac7f2ed3fa259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78ee545db851130be4ac7f2ed3fa259">&#9670;&nbsp;</a></span>LookupType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * SymbolTable::LookupType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a type of the given name in the symbol table.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classType.html" title="Interface class that defines the type abstraction. ">Type</a>, if found; otherwise NULL is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00180">180</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00274">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00165">AddType()</a>.</p>

</div>
</div>
<a id="a4c89545a31f6a562bb10089b79fa5c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c89545a31f6a562bb10089b79fa5c08">&#9670;&nbsp;</a></span>LookupVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * SymbolTable::LookupVariable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a variable with the given name in the symbol table. This method searches outward from the innermost scope to the outermost, returning the first match found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable to be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a>, if a match is found. NULL if no <a class="el" href="classSymbol.html" title="Representation of a program symbol. ">Symbol</a> with the given name is in the symbol table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00112">112</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

<p class="reference">Referenced by <a class="el" href="module_8cpp_source.html#l00865">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00538">Module::AddGlobalVariable()</a>, <a class="el" href="stmt_8cpp_source.html#l02206">ForeachUniqueStmt::ForeachUniqueStmt()</a>, <a class="el" href="func_8cpp_source.html#l00092">Function::Function()</a>, and <a class="el" href="module_8cpp_source.html#l02894">lExtractOrCheckGlobals()</a>.</p>

</div>
</div>
<a id="aa79caf59c28df4805abaf2ce5df83198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79caf59c28df4805abaf2ce5df83198">&#9670;&nbsp;</a></span>PopScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::PopScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each scope started by a call to <a class="el" href="classSymbolTable.html#ae8daa1cf8667258e065b8be95facb330">SymbolTable::PushScope()</a>, there must be a matching call to <a class="el" href="classSymbolTable.html#aa79caf59c28df4805abaf2ce5df83198">SymbolTable::PopScope()</a> at the end of that scope. </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00079">79</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="sym_8h_source.html#l00261">freeSymbolMaps</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00061">~SymbolTable()</a>.</p>

</div>
</div>
<a id="a6642684baa5464f91821d8a83595bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6642684baa5464f91821d8a83595bb7b">&#9670;&nbsp;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::Print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints out the entire contents of the symbol table to standard error. (Debugging method). </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00272">272</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00269">functions</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="sym_8h_source.html#l00070">Symbol::name</a>, <a class="el" href="sym_8h_source.html#l00083">Symbol::type</a>, <a class="el" href="sym_8h_source.html#l00274">types</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

</div>
</div>
<a id="ae8daa1cf8667258e065b8be95facb330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8daa1cf8667258e065b8be95facb330">&#9670;&nbsp;</a></span>PushScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::PushScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parser calls this method when it enters a new scope in the program; this allows us to track variables that shadows others in outer scopes with same name as well as to efficiently discard all of the variables declared in a particular scope when we exit that scope. </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00067">67</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="sym_8h_source.html#l00261">freeSymbolMaps</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00059">SymbolTable()</a>.</p>

</div>
</div>
<a id="a8d2502ae8d176fc65f5f3f35a74e8c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2502ae8d176fc65f5f3f35a74e8c50">&#9670;&nbsp;</a></span>RandomSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * SymbolTable::RandomSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random symbol from the symbol table. (It is not guaranteed that it is equally likely to return all symbols). </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00315">315</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, <a class="el" href="sym_8cpp_source.html#l00307">ispcRand()</a>, and <a class="el" href="sym_8h_source.html#l00259">variables</a>.</p>

</div>
</div>
<a id="abffa882da18fadc3eaedb33c9e6fe0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffa882da18fadc3eaedb33c9e6fe0de">&#9670;&nbsp;</a></span>RandomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * SymbolTable::RandomType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random type from the symbol table. </p>

<p class="definition">Definition at line <a class="el" href="sym_8cpp_source.html#l00328">328</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p class="reference">References <a class="el" href="ispc_8h_source.html#l00161">Assert</a>, and <a class="el" href="sym_8h_source.html#l00274">types</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54f0654be5acf123bb1361b70254a820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f0654be5acf123bb1361b70254a820">&#9670;&nbsp;</a></span>freeSymbolMaps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolMapType</a> *&gt; SymbolTable::freeSymbolMaps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00261">261</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00079">PopScope()</a>, and <a class="el" href="sym_8cpp_source.html#l00067">PushScope()</a>.</p>

</div>
</div>
<a id="a6a9ed3c8090d2ef62ec1af29c7980848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9ed3c8090d2ef62ec1af29c7980848">&#9670;&nbsp;</a></span>functions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolTable.html#a572ca48a60a649d7fb9acf4dbf216dbd">FunctionMapType</a> SymbolTable::functions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00269">269</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00126">AddFunction()</a>, <a class="el" href="sym_8cpp_source.html#l00199">ClosestVariableOrFunctionMatch()</a>, <a class="el" href="sym_8h_source.html#l00278">GetMatchingFunctions()</a>, <a class="el" href="sym_8cpp_source.html#l00139">LookupFunction()</a>, and <a class="el" href="sym_8cpp_source.html#l00272">Print()</a>.</p>

</div>
</div>
<a id="a958f9beda85202e291efe9816a0cd717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958f9beda85202e291efe9816a0cd717">&#9670;&nbsp;</a></span>types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a> SymbolTable::types</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00274">274</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00165">AddType()</a>, <a class="el" href="sym_8cpp_source.html#l00242">closestTypeMatch()</a>, <a class="el" href="sym_8cpp_source.html#l00188">ContainsType()</a>, <a class="el" href="sym_8cpp_source.html#l00180">LookupType()</a>, <a class="el" href="sym_8cpp_source.html#l00272">Print()</a>, and <a class="el" href="sym_8cpp_source.html#l00328">RandomType()</a>.</p>

</div>
</div>
<a id="aabcd388428ccc659020d47e9cb441606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcd388428ccc659020d47e9cb441606">&#9670;&nbsp;</a></span>variables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSymbolTable.html#aef2544e5039654a9583a927e73995d1b">SymbolMapType</a> *&gt; SymbolTable::variables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sym_8h_source.html#l00259">259</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sym_8cpp_source.html#l00085">AddVariable()</a>, <a class="el" href="sym_8cpp_source.html#l00199">ClosestVariableOrFunctionMatch()</a>, <a class="el" href="sym_8h_source.html#l00292">GetMatchingVariables()</a>, <a class="el" href="sym_8cpp_source.html#l00112">LookupVariable()</a>, <a class="el" href="sym_8cpp_source.html#l00079">PopScope()</a>, <a class="el" href="sym_8cpp_source.html#l00272">Print()</a>, <a class="el" href="sym_8cpp_source.html#l00067">PushScope()</a>, <a class="el" href="sym_8cpp_source.html#l00315">RandomSymbol()</a>, and <a class="el" href="sym_8cpp_source.html#l00061">~SymbolTable()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="sym_8h_source.html">sym.h</a></li>
<li><a class="el" href="sym_8cpp_source.html">sym.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 20 2019 02:49:41 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
